<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    
    <title><![CDATA[devthewild]]></title>
    <link>http://seoh.github.io/blog//</link>
    <atom:link href="/blog/rss.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[most opinionated blog]]></description>
    <pubDate>Wed, 10 Jun 2015 12:54:55 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Spark로 빅데이터 입문, 1-2주차 노트]]></title>
      <link>http://seoh.github.io/blog/2015/06/10/big-data-with-spark-1-2-week/</link>
      <guid>http://seoh.github.io/blog/2015/06/10/big-data-with-spark-1-2-week/</guid>
      <pubDate>Wed, 10 Jun 2015 12:18:51 GMT</pubDate>
      <description>
      <![CDATA[edX에서 Spark로 빅데이터 입문(Introduction to Big Data with Apache Spark)을
듣고 있다. UC Berkeley의 Anthony Joseph 교수가 진행하는 수업으로, 실제 데이터를 가지고 과제
4개를 진행하면서 Spark로 빅데이터 분석하는 방법을 배운다고 하는데, 수업 난이도 자체는 높지 않다.
대상은 Python]]>
      </description>
      <content:encoded><![CDATA[<p>edX에서 <a href="https://courses.edx.org/courses/BerkeleyX/CS100.1x/1T2015" target="_blank" rel="external">Spark로 빅데이터 입문(Introduction to Big Data with Apache Spark)</a>을
듣고 있다. UC Berkeley의 Anthony Joseph 교수가 진행하는 수업으로, 실제 데이터를 가지고 과제
4개를 진행하면서 Spark로 빅데이터 분석하는 방법을 배운다고 하는데, 수업 난이도 자체는 높지 않다.
대상은 Python 경험자로 분산 컴퓨팅/Spark에 대한 지식은 없어도 된다고 되어있다. 환경 설정도
Jupyter(IPython Notebook의 새 이름)와 PySpark가 이미 세팅된 환경을 Vagrant로 제공해주는데,
Vagrant의 이름만 알고 있는 정도였지만 동영상에서 OS별로 제공하는 동영상을 보고 따라하면 된다.</p>
<p>실습은 노트북 파일에서 비어있는 부분을 채우면서 진행하면 되는데, 의도에 대한 설명은 코드 위에 충분히
자세하게 되어있고 단계별 진행이다보니 정확히 읽지 않아도 코드를 보면서 따라가면 유추가 가능하다.
단순히 유행어(Buzzword) 이상으로 Big Data나 Spark에 대해 배워보고 싶은 사람들에게 추천할 겸,
몇달 뒤에 잊어먹을 나 자신을 위해서 기록을 남겨본다.</p>
<h1>1주차</h1>
<p>환경설정: Jupyer + PySpark가 세팅된 vagrant 올리기</p>
<p>수업 목표</p>
<ul>
<li>Data Science를 배워보자</li>
<li>실제 데이터를 다루는 과정</li>
<li>Spark(w/ mllib)를 써보자</li>
</ul>
<h3>Lecture 1. Big Data와 Data Science 소개</h3>
<ul>
<li>데이터 분석의 역사</li>
<li>원인 ≠ 상관관계</li>
<li>충분한 데이터가 필요</li>
<li>현재를 분석하는건 쉽고 미래를 예측하는건 어렵다</li>
<li>사건에 대한 중요한 요인을 모두 알고 있어야한다</li>
<li>(MySpcae 사례를 통한 페이스북 유행시기 추정 -&gt; 실패)</li>
</ul>
<p>빅데이터는 어디에서?</p>
<ul>
<li>사용자들이 올리는 컨텐츠들(웹/모바일) - 페이스북, 인스타그램, 옐프</li>
<li>생체정보/과학쪽 연산</li>
</ul>
<p>그래프 데이터</p>
<ul>
<li>많은 데이터들이 그래프 구조</li>
<li>SNS, 네트워크 등</li>
</ul>
<p>사람이 보기에 너무 많은 정보</p>
<ul>
<li>아파치 서버 로그</li>
<li>IoT의 센서 측정기록</li>
</ul>
<p>빅데이터를 어떻게 다룰까</p>
<ul>
<li>Crowdsourcing</li>
<li>Physical modeling</li>
<li>Sensing</li>
<li>Data Assimilation</li>
</ul>
<p>많은 사람들에게서 정보를 얻어 분석한 다음에 중요한 정보를 시각화</p>
<h3>Lecture 2. Data Science는 어떻게? 데이터 준비하기</h3>
<ul>
<li>코딩 + 도메인 지식만으로는 잘못된 분석의 가능성</li>
<li>Data Science = 코딩 + 도메인 + 통계지식</li>
</ul>
<p><a href="http://drewconway.com/zia/2013/3/26/the-data-science-venn-diagram" target="_blank" rel="external">The Data Science Venn Diagram</a></p>
<p>Database와 Data Science의 차이</p>
<ul>
<li>데이터가 중요하다 / 싸다</li>
<li>원자성이 중요 / 결과적으로 유지만되면 오케이</li>
<li>과거를 조회 / 미래를 예측</li>
<li>정해진 복잡도 / 하다보면 됨</li>
</ul>
<p>방법</p>
<ul>
<li>Jim Gray 모델 vs Ben Fry 모델 vs Jeff Hammerbacher 모델</li>
</ul>
<p>어려움</p>
<ul>
<li>실제 데이터는 너무 더러움</li>
<li>이전에 발견한 패턴/가설이 선입견</li>
</ul>
<p>준비: ETL</p>
<ul>
<li>extract: 데이터 추출</li>
<li>transform: 가공</li>
<li>load: 모아놓는다</li>
</ul>
<h1>2주차</h1>
<h3>Lecture 3. 빅 데이터, Spark</h3>
<p>왜 필요한가?</p>
<ul>
<li>페이스북의 하루 로그는 60TB</li>
<li>이제 머신 하나에서 다룰 수 없다</li>
</ul>
<p>거대한 문서에서 단어를 세는 예제</p>
<ul>
<li>머신 n-to-1
<ul>
<li>문단 별 단어 카운트는 n개에서 나눠서 해도 된다</li>
<li>합치는 작업을 1개에서 한다면 병목</li>
</ul>
</li>
<li>머신 n-to-n
<ul>
<li>합치는 작업도 단어별로 n개에서 나눠서</li>
<li>이게 Map/Reduce 개념</li>
</ul>
</li>
<li>문제
<ul>
<li>머신끼리 데이터 보내는건 느리다</li>
<li>하나가 실패하면? -&gt; 그 머신만 다시 시작</li>
<li>하나가 느리면? -&gt; 하나 더 돌리고 먼저 끝난걸 선택</li>
</ul>
</li>
<li>문제 2
<ul>
<li>작업을 반복해서할 때 디스크에 저장하면 I/O가 병목</li>
<li>메모리에 올려서 작업하면? -&gt; Spark</li>
</ul>
</li>
</ul>
<p>Spark</p>
<ul>
<li>위에서 말한 실패하거나 느린 노드를 자동으로 처리</li>
<li>Core와 컴포넌트 4개 Spark SQL, Spark Streaming, MLlib, GraphX로 구성</li>
<li>disk에 넣기 위해 serialization/deserialization 할 필요가 없으므로 100배 이상 빠르다</li>
</ul>
<p>특징</p>
<ul>
<li>다양한 경우에 쓸 수 있는 엔진</li>
<li>리니지(immutable을 이용한 이력관리)의 lazy eval</li>
</ul>
<h3>Lecture 4. Spark 기초</h3>
<ul>
<li>어플리케이션(driver)에서 SparkContext로 시작</li>
<li>worker는 클러스터 혹은 로컬 스레드</li>
<li>분산된 worker의 추상화가 RDD</li>
</ul>
<p>맨 처음 실행하면</p>
<ul>
<li>SparkContext 객체의 인스턴스 <code>sc</code> 생성</li>
<li><code>sc</code>로 로컬의 worker 접근, 혹은 hdfs, mesos 접근</li>
</ul>
<p>RDD는</p>
<ul>
<li>만들어지면 불변</li>
<li>transform되는 과정(lineage)을 추적해서 재사용 가능</li>
<li>파티션을 설정하면 그만큼 병렬처리</li>
</ul>
<p>연산은</p>
<ul>
<li>transformation, action 두 종류</li>
<li>transform: lazy eval, action까지 미뤄둠</li>
<li>persis(cache)는 메모리/디스크 저장</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">rDD = sc.parallelize(data, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>혹은</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = sc.textFile(<span class="string">"README.md"</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>transformation</p>
<ul>
<li>map, filter, distinct, flatMap,</li>
</ul>
<p>action</p>
<ul>
<li>바로 계산</li>
<li>reduce, take, collect, takeOrdered</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lines = sc.textFile(<span class="string">"..."</span>, <span class="number">4</span>)</span><br><span class="line">comments = lines.filter(isComment)</span><br><span class="line"><span class="keyword">print</span> lines.count(), comments.count()</span><br></pre></td></tr></table></figure>
<p>lines 연산을 한번, lines+comments 연산을 한번해서 중복. 그럴 때는 중간에 <code>lines.cache()</code></p>
<p>key-value transformation</p>
<ul>
<li>reduceByKy, sortByKe, groupByKey</li>
<li>groupByKey는 데이터가 이동하므로 네트워크/대량에서는 주의</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rdd // [(<span class="number">1</span>,<span class="number">2</span>), (<span class="number">3</span>,<span class="number">4</span>), (<span class="number">3</span>,<span class="number">6</span>)]</span><br><span class="line">rdd.reduceByKey(<span class="keyword">lambda</span> a, b: a + b) // [(<span class="number">1</span>,<span class="number">2</span>), (<span class="number">3</span>,<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>
<p>closure</p>
<ul>
<li>broadcase: driver가 쓰면 worker들이 읽기 가능</li>
<li>accumulator: worker들이 쓰기만 가능 driver만 접근가능</li>
</ul>
<h1>Lab 1. Spark 과제</h1>
<p>구텐베르크 프로젝트에서 셰익스피어 전집의 데이터로 단어 세기</p>
<ul>
<li>특수문자 제거</li>
<li>띄어쓰기로 단어 구분</li>
<li>중복 제거를 위해 소문자로 변환</li>
<li>최빈 15개 단어</li>
</ul>
<hr>
<p>참고로 강의노트(PDF)가 공개되어있다.</p>
<ul>
<li><a href="https://courses.edx.org/c4x/BerkeleyX/CS100.1x/asset/Week1Lec1.pdf" target="_blank" rel="external">Lecture 1 slides</a></li>
<li><a href="https://courses.edx.org/c4x/BerkeleyX/CS100.1x/asset/Week1Lec2.pdf" target="_blank" rel="external">Lecture 2 slides</a></li>
<li><a href="https://courses.edx.org/c4x/BerkeleyX/CS100.1x/asset/Week2Lec3.pdf" target="_blank" rel="external">Lecture 3 slides</a></li>
<li><a href="https://courses.edx.org/c4x/BerkeleyX/CS100.1x/asset/Week2Lec4.pdf" target="_blank" rel="external">Lecture 4 slides</a></li>
</ul>
]]></content:encoded>
      <comments>http://seoh.github.io/blog/2015/06/10/big-data-with-spark-1-2-week/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[나는 왜 크롬을 쓰는가]]></title>
      <link>http://seoh.github.io/blog/2015/06/07/why-i-cannot-use-safari-and-firefox/</link>
      <guid>http://seoh.github.io/blog/2015/06/07/why-i-cannot-use-safari-and-firefox/</guid>
      <pubDate>Sat, 06 Jun 2015 17:16:58 GMT</pubDate>
      <description>
      <![CDATA[사람들이 크롬하면 생각하는 대표적인 장단점으로는 강력한 확장과 강력한 메모리(흡수)가 있다.
아무 이유 없이 수많은 프로세스와 수많은 메모리를 잡아먹지는 않을테니 그 트레이드오프가 내부적으로는
앞으로 쓸 이야기와 관련있을 수도 있지만, 내가 크롬을 쓰는 이유는 (직접적으로)이것들 때문은 아니다.
일단 내 패턴에서 브라우저의 기본 조건은 다음과 같다.

죽는]]>
      </description>
      <content:encoded><![CDATA[<p>사람들이 크롬하면 생각하는 대표적인 장단점으로는 강력한 확장과 강력한 메모리(흡수)가 있다.
아무 이유 없이 수많은 프로세스와 수많은 메모리를 잡아먹지는 않을테니 그 트레이드오프가 내부적으로는
앞으로 쓸 이야기와 관련있을 수도 있지만, 내가 크롬을 쓰는 이유는 (직접적으로)이것들 때문은 아니다.
일단 내 패턴에서 브라우저의 기본 조건은 다음과 같다.</p>
<ul>
<li>죽는 건 상관없지만 죽은 뒤에 탭 목록이 유지될 것</li>
</ul>
<p>패턴이라는 게 별것 없다. 트위터, RSS, 뉴스레터에 올라온 링크들을 브라우저에 최대한(약 50개)으로
올려놓고 빠르게 훑어본 뒤 필요 없다고 판단된 것들은 닫고 정독할 것들을 쌓아둔다. 예전에는 그냥 닫거나
포켓에 넣거나 둘 중 하나였는데, 포켓이 반응속도가 느려진 뒤로 포켓을 거치지 않고 그냥 브라우저에
띄워놓고 있다. 다양한 곳에서 하루에 세 자리 단위의 링크들을 띄우고 정리하다보니 어디까지 읽었는지,
어떤 것을 정독하려고 판단했는지의 목록이 사라지면 그것을 다시 복구하는 것만 해도 경험상 두세 시간 이상은
걸리게 되니 탭 목록이 사라지는데 매우 민감해졌다. 물론 공식적으로 사파리/파이어폭스도 탭 목록을
유지해준다.</p>
<p>사파리에서는 다시 열었을 때, 마지막 세션에서 모든 윈도우를 다시 자동으로 열어주는 옵션도 있고, 혹여
저 옵션을 선택하지 않았거나 비정상적으로 종료되었을 때 마지막 세션의 모든 윈도우를 다시 열게 해주는
기능이 존재한다. 그리고 Session 등 주기적으로 세션을 백업해두는 확장도 존재하긴 한다. 다만,
비정상적으로 종료당하는 일이 그리 많지는 않은데 그럴 때 앞에서 언급한 기능들에서 제대로 목록을
살려주는 경우가 별로 없다. 맥에서 가장 미려하고 반응속도도 좋은 사파리라 사파리나 OS X의 메이저
업데이트때마다 항상 재도전을 하고 있지만 항상 실패했다. 물론 10.11이나 Safari 9이 나오면 또
도전할 예정이다. 하지만 그리 큰 기대를 하진 않는다.</p>
<p>파이어폭스도 마찬가지지만 비정상 종료의 모습이 약간 다르다. 사파리는 &quot;뿅! 사파리가 사라졌습니다&quot;
하면서 갑자기 튕긴다면, 파이어폭스는 갑자기 &quot;나 죽어어어어어어어어&quot;하면서 CPU 점유율이 100%를
넘어가며 주변에 민폐를 끼쳐서 어쩔 수 없이 강제종료하게 만든다. IE 6, 7 시절부터 쓰기 시작해서
크롬으로 넘어가기 전에 메인으로 쓰다가, 크롬이 지나치게 무거워져서 돌아간 게 20대 후반 버전이었던
것으로 기억하는데 파이어폭스도 그때부터 메이저 버전때마다 도전했지만 항상 저런 증상 때문에 실패했다.
Session Manager 등 확장들을 찾아봤지만 평소에도 느리게 만들고 구동시간을 느리게 만들 뿐이었다.</p>
<hr>
<p>사파리가 다른 두 브라우저에 비해 개발도구의 기능은 <strong>매우</strong> 떨어지나, 메모리/배터리 효율 면에서
비교하기 어려울 정도로 좋다는 장점이 있고, 파이어폭스는 개발도구로써 최신 기술이 가장 먼저 들어가고
<a href="https://hacks.mozilla.org/2014/07/event-listeners-popup-media-sidebar-cubic-bezier-editor-more-firefox-developer-tools-episode-33/" target="_blank" rel="external">Event listeners popup</a>처럼 다른 브라우저에서 찾기 힘든 편리한 기능 등이 있다.</p>
<p>저 브라우저들이 내 머신들에서만 같은 문제를 발생하는 것일 수도 있고, 하루에 몇백 개의 링크를 훑어봐야하는
사람이 많지도 않을테니 누군가에게 동의를 구할 수도 없고 그럴 생각도 없는 이유지만, 이것이 내가 크롬을
쓸 수 밖에 없는 이유다.</p>
]]></content:encoded>
      <comments>http://seoh.github.io/blog/2015/06/07/why-i-cannot-use-safari-and-firefox/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[흥미로운 ECMAScript 제안들]]></title>
      <link>http://seoh.github.io/blog/2015/05/31/interesting-es-proposal/</link>
      <guid>http://seoh.github.io/blog/2015/05/31/interesting-es-proposal/</guid>
      <pubDate>Sun, 31 May 2015 07:58:22 GMT</pubDate>
      <description>
      <![CDATA[RSS에 글이 뜸해질 때는 Coven을 보는데, Hacker News, /r/programming
(Reddit의 프로그래밍 서브레딧- 게시판 개념) 등 사이트 4개의 추천 상위 글을 실시간으로 가져오는 곳이다.
다른 곳에도 공유하긴 했지만, 여기 올라온 글 중에서 흥미로운 ES의 제안(제안-초안-후보-마감의 단계 중 첫 번째)에 해당하는 것 2개를 소개하]]>
      </description>
      <content:encoded><![CDATA[<p>RSS에 글이 뜸해질 때는 <a href="http://www.coven.link/" target="_blank" rel="external">Coven</a>을 보는데, <a href="https://news.ycombinator.com/" target="_blank" rel="external">Hacker News</a>, <a href="http://www.reddit.com/r/programming" target="_blank" rel="external">/r/programming
</a>(Reddit의 프로그래밍 서브레딧- 게시판 개념) 등 사이트 4개의 추천 상위 글을 실시간으로 가져오는 곳이다.
다른 곳에도 공유하긴 했지만, 여기 올라온 글 중에서 흥미로운 ES의 제안(제안-초안-후보-마감의 단계 중 첫 번째)에 해당하는 것 2개를 소개하려고 한다.</p>
<h2>1. <a href="https://docs.google.com/document/d/1Qk0qC4s_XNCLemj42FqfsRLp49nDQMZ1y7fwf5YjaI4/preview" target="_blank" rel="external">&quot;use strong&quot; mode in ES6</a></h2>
<p>ES5의 &quot;use strict&quot;를 포함하는 개선된(빡쎈) 버전이다. V8의 경우 예측할 수 있는 경우에는 최적화된 컴파일러를, 아닌 경우에는 일반 컴파일러를 실행한다고
되어있는 <a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#some-v8-background" target="_blank" rel="external">글</a>이 있었는데, 다른 구현체들의
정확한 internal은 잘 모르겠지만 컨셉 자체는 다른 곳에도 적용가능해보인다. 다시 말해서, 프로그램 흐름과 객체 상태를 제약해서 유지보수를 편하게 하고
성능을 좋게 한다는 아이디어에 대한 구체적인 제약들이다. 대표적으로 <code>var</code>와 <code>delete</code>를 금지하는 문법상 제약이 있다. <code>var</code>를 금지하는 대신 <code>let</code>을
사용해서 lexical scope의 범위를 줄여서 컴파일러나 사람이 생각해야하는 양을 줄이겠다는 것으로 보인다. 그리고 <code>delete</code>를 금지하면 객체의 형태가 고정
(seal)되어 형태에 대한 정보를 재사용하고 예측가능해진다.
(참고, ES6의 <code>Object.freeze</code>와 <code>Object.seal</code>의 차이에 대한 <a href="http://stackoverflow.com/questions/21402108/difference-between-freeze-and-seal-in-javascript" target="_blank" rel="external">답변</a>)</p>
<h2>2. <a href="https://docs.google.com/file/d/1uEVcOgJIMsHjN1vypKKyfmDRg_bz5cKXpo0v4Nc0q8NfqKolBeSDHIj8z9GS8A4EiMpZ8QQ3l87Q_wF3/preview" target="_blank" rel="external">ES2016 Observable</a></h2>
<p>ES6의 Generator와 ES7의 async/await를 합치면 비슷한 구현은 가능하지만, async generator의 경우에 IO에는 적합하지만 Push(Event, WebSocket)
등에는 적합하지 않는다. 즉 async는 producer를 observable은 consumer를 만들 때 적합하다(하지만 이해를 잘못한 것인지 슬라이드에는 반대로 되어있다).
사실 이게 들어갈 확률은 매우 적어 보이지만, 요즘 듣고 있는 Coursera의 <a href="https://class.coursera.org/reactive-002/" target="_blank" rel="external">reactive programming</a>에서
Rx에 대한 내용이 나오다 보니 그쪽으로 관심이 생겨서 RxJS도 써보고 싶은데 마침 이 제안을 발견해서 기억에 남았다.</p>
<hr>
<p>ps 1, 이것들 말고도 hn/reddit에 추천 상위로 올라온 게 더 있지만 재미가 없었는지 키워드도 기억나지 않는 게 많다.</p>
<p>ps 2, 흥미로운 것들을 발견하면 실시간으로 트위터에 올리고 있다. <a href="https://twitter.com/@devthewild" target="_blank" rel="external">@devthewild</a></p>
<p>ps 3, 구직중</p>
]]></content:encoded>
      <comments>http://seoh.github.io/blog/2015/05/31/interesting-es-proposal/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Callback에서 Future로(그리고 Functor, Monad)]]></title>
      <link>http://seoh.github.io/blog/2015/05/28/callback-to-future-functor-applicative-monad/</link>
      <guid>http://seoh.github.io/blog/2015/05/28/callback-to-future-functor-applicative-monad/</guid>
      <pubDate>Thu, 28 May 2015 00:39:49 GMT</pubDate>
      <description>
      <![CDATA[
Translation of &quot;From callback to (Future -&gt; Functor -&gt; Monad)&quot; into Korean, under the same license as the original.

동기
함수형 프로그래밍에서 기본개념은 조합(composition) 이다. 간단히 설명해서, 단순한 것들을 엮어서 더
복]]>
      </description>
      <content:encoded><![CDATA[<blockquote>
<h3>Translation of &quot;<a href="http://tech.pro/blog/6742/callback-to-future-functor-applicative-monad" target="_blank" rel="external">From callback to (Future -&gt; Functor -&gt; Monad)</a>&quot; into Korean, under the same license as the original.</h3>
</blockquote>
<h2>동기</h2>
<p>함수형 프로그래밍에서 기본개념은 <strong>조합(composition)</strong> 이다. 간단히 설명해서, 단순한 것들을 엮어서 더
복잡한 것을 만들 수 있고 그 결과를 다시 엮어서 더 복잡한 것을 만들 수도 있다. 함수의 의미나 리턴값이
무엇인지만 알고 있으면 조합으로 무엇이든 만들어낼 수 있다.</p>
<p>Node.js를 써봤으면 아래와 같은코드를 본 적이 있을 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'...'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  ....</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>위의 코드는 전형적인 CPS(continuation-passing style) 함수이다. <code>fs.readFile</code>이라는 CPS
함수는 계속(continuation) 진행될 콜백을 추가 파라미터로 받는다. 이 CPS가 끝나면 호출한 곳에 값을
반환하는게 아니라 계속 함수, 콜백에 계산 결과를 넘겨준다.</p>
<p>나는 콜백을 쓰는걸 꺼리진 않는다. 사실 콜백은 부수효과를 표현하거나 이벤트 알림같은 것을 다룰 때
훌륭하다. 그렇지만 그걸로 흐름을 관리하기 시작하면 함정에 빠진 것이다. 왜냐면 조합할 수 없기 때문에.</p>
<p>자, 생각해보자. &quot;위에 나온 함수의 **표기(denotation)**나 리턴값은 무슨 의미일까?&quot; 답은
<code>undefined</code>이다. undefined라는건 테스트할 때 실제로 undefined인지 확인하는 용도 이외에는 쓸
데가 없다.</p>
<p>콜백 안에서 다른 실행 흐름으로 넘어갈 때 일방통행이라는게 문제다.</p>
<p>물리학에서 유명한 블랙홀처럼 콜백을 생각해보자:</p>
<blockquote>
<p>블랙홀은 수학적으로 정의된 지역이다. 강한 인력이 작용하거나, 어떤 티끌이나 전자기적 파장조차
빠져나갈 수 없는</p>
</blockquote>
<p>그 중에서도</p>
<blockquote>
<p>어떤 빛도 반사하지 않는 등 블랙홀은 많은 부분에서 이상적인 검은 물체처럼 작용한다.</p>
</blockquote>
<p>콜백 함수 또한 흐름에서의 어떤 것도 반사하지 못한다.</p>
<p>나중에 첫번째 콜백에 들어갈 때 다른 콜백 스타일 함수를 쓸 수 있는데, 그때는 두번째 <strong>흐름</strong>을 잃게
되고 다른 구멍에 빠지게 된다. 콜백을 쓰면 쓸 수록 지옥에 빠지게 된다.</p>
<p>그럼 블랙홀에 빠지지 않고 코드를 진행할 수는 없을까?</p>
<p>답은 <strong>조합</strong>이다. 하지만 조합을 사용하려면 일단 CPS 함수가 어디로도 돌아갈 수 없다는 사실을
알아야하고, 함수로부터 뭔가를 받아와야한다. 그러니 어떻게든 함수가 뭔가를 반환하게 만들어야한다. 어떤
값이 반환될까? 이게 이 글의 동기이다.</p>
<p>이미 자바스크립트에서의 해답을 알고 있을 수 있다. 하지만 계속 이 글을 읽도록, 강하게, 추천한다.
지시적인(즉 함수형) 생각의 힘을 보게 될 것이고, 깔끔하고 간결한 해답을 어떻게 사용할지 보게 될 것이다.</p>
<h2>future로 입문</h2>
<p>파일 읽기, 네트워크 요청, DOM 이벤트, 이런 함수들의 공통점은 뭘까?</p>
<p>이 함수들은 <em>즉시</em> 완료되지 않는 것들이다. 즉, (보통 함수들을 다루는 식으로는) 현재 프로그램
흐름에서 저 함수들이 완료될 때까지 기다릴 수 없다는 뜻이다. 그래서 _future_를 설명할 것이다.</p>
<p>그래서 특별한 반환 타입, 나중에 결과를 만들어준다고 명시하는 <code>Future</code>를 만들어보자. 요점은 다른
함수들로 넘길 수 있는 1등급 클래스 값을 사용하는 것이다.</p>
<p>Future는 무슨 의미일까? 특정 시간(0이 될 수도 있다) 후에 발생할 것이라고 명시해놓은 값이다.
그 시간은 우리가 x초 후라고 말하는 것처럼 명시적인 시간이 될 수도 있지만, Future 2개가 완료된 후
혹은 Future 하나가 완료된 뒤 다른 Future 완료될 때처럼 상대적인 개념일 수도 있다.</p>
<p>여기서 중요한 점은: <strong>Future의 결과는 항상 불변값이다.</strong></p>
<p>즉, 완료 값을 어떤 방법으로든 변경할 수 없다. 이 제약으로 구현 뿐만 아니라 의미론에 대한 추론도
간단해진다.</p>
<p>Future는 일회용의 간단한 상태머신처럼 구현될 수 있다. 이 머신은 <em>대기</em> 로 시작했다가 <em>완료</em> 가 된
후에 멈춘다. 한번 완료되면 계속 완료상태에 고정된다.</p>
<p>내부적으로 <code>Future</code>는 콜백에 여전히 의존하고 있지만, 그 콜백들이 컨트롤 흐름 매커니즘을 방해하지는
않는다. 대신 올바른 목적으로만 사용된다, 이벤트 알림.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Future</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 대기중인 구독들을 저장하는 리스트</span></span><br><span class="line">  <span class="keyword">this</span>.slots = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 완료를 알린다</span></span><br><span class="line">Future.prototype.ready = <span class="function"><span class="keyword">function</span>(<span class="params">slot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.completed) slot(<span class="keyword">this</span>.value);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">this</span>.slots.push(slot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 간단한 로그 유틸리티</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logF</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  f.ready( v =&gt; <span class="built_in">console</span>.log(v) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Future를 완료시키는 외부 인터페이스로 메소드가 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.complete = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 불변성 보장</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.completed)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"이미 완료된 Future는 완료시킬 수 없다."</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.value = val;</span><br><span class="line">  <span class="keyword">this</span>.completed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 구독들에게 알림</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, len=<span class="keyword">this</span>.slots.length; i&lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>.slots[i](val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 모두 실행되면 이제 필요없다.</span></span><br><span class="line">  <span class="keyword">this</span>.slots = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Future의 가장 간단한 예제로 어떤 값으로 <em>즉시</em> 완료시켜보자. 그 역할을 <code>unit</code>이란 메소드를
만들어보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unit: Value -&gt; Future&lt;Value&gt;</span></span><br><span class="line">Future.unit = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fut = <span class="keyword">new</span> Future();</span><br><span class="line">  fut.complete(val);</span><br><span class="line">  <span class="keyword">return</span> fut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logF( Future.unit(<span class="string">'hi now'</span>) );</span><br></pre></td></tr></table></figure>
<p>코드에 대해 간단히 설명하기 위해 <em>타입 표기(type annotation)</em> 를 사용했다.</p>
<p><code>unit: Value -&gt; Future&lt;Value&gt;</code>를 풀어보면 1- <code>unit</code>은 함수고, 2- 제네릭 타입 <code>Value</code>를
입력으로 받으며, 3- 제너릭 타입을 가진 <code>Future</code> 인스턴스를 리턴한다. 여기서 타입 정보는 중요하지
않으므로 <code>Value</code>라는 제너릭은 신경쓰지 않아도 된다.</p>
<p>다음 예제는 특정 시간이 지나고 완료되는 값이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delay: (Value, Number) -&gt; Future&lt;Value&gt;</span></span><br><span class="line">Future.delay = <span class="function"><span class="keyword">function</span>(<span class="params">v, millis</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">new</span> Future();</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    f.complete(v);</span><br><span class="line">  &#125;, millis);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logF( Future.delay(<span class="string">'안녕, 이건 5초 걸린다'</span>, <span class="number">5000</span>) );</span><br></pre></td></tr></table></figure>
<p><code>delay</code>의 결과는 주어진 값만큼의 시간이 지난 뒤에 완료되는 Future다.</p>
<p>readFile 예제로 돌아가서, 이제 CPS 함수 대신에 Future를 리턴하는 함수를 사용할 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// readFileF: (String, Object) -&gt; Future&lt;String&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFileF</span>(<span class="params">file, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">new</span> Future();</span><br><span class="line">  fs.readFile(file, options, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 에러는 잠시 후에 다루겠다</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    f.complete(data);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logF( readFileF(<span class="string">'test.txt'</span>, &#123;encoding: <span class="string">'utf8'</span>&#125;) );</span><br></pre></td></tr></table></figure>
<p><code>readFileF</code>의 결과는 인자로 받은 파일 이름의 내용을 잡고 있는 Future가 된다.</p>
<h2>Future 다루기: 첫번째 게스트</h2>
<p><code>Future</code>를 결과적으로 함수의 결과를 잡고 있는 마법 상자처럼 생각할 수도 있다.</p>
<p>뭔가 쓸모있는 것을 하려면 Future 타입에서 쓸모있는 연산들을 제공해야한다. 아니면 그냥 쓸모없는
<code>undefined</code>만 만들어낼 뿐이다. (?)</p>
<p>그러면 어떤 연산을 Future에서 제공해야할까?</p>
<p>Future 상자에서 잡고 있는 값에 어떤 연산을 하고 싶을 때 (function map을 줄인)<code>fmap</code>을 호출할
것이다.</p>
<p><code>fmap</code>의 예제를 보자. 여기서 Future는 텍스트 파일의 내용을 잡고 있고, 이 내용의 길이를 계산하려고
한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textF = readFileF(<span class="string">'test.txt'</span>, &#123;encoding: <span class="string">'utf8'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmap: (Future&lt;String, (String -&gt; Number)&gt; -&gt; Future&lt;Number&gt;)</span></span><br><span class="line"><span class="keyword">var</span> lengthF = textF.fmap( text =&gt; text.length );</span><br><span class="line">logF( lengthF );</span><br></pre></td></tr></table></figure>
<p><code>lengthF</code>의 뜻은 인자로 받은 Future가 잡고 있는 파일 내용의 길이를 잡고 있는 Future다.</p>
<p>일반화를 해보자면, <code>fmap</code>은 인자를 둘 받는데, 하나는 값을 잡고 있는 Future고 하나는 일반값을
다루는 매핑 함수다. 입력으로 받은 Future의 결과물에 매핑 함수를 적용한 결과를 잡고 이는 Future가
결과로 나온다. 받은 Future와 결과 Future는 둘 다 동시에 완료된다.</p>
<p>정확하진 않지만, 이렇게 표현할 수 있다</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmap( Future&lt;value&gt;, func ) = Future&lt; func(value) &gt;</span><br></pre></td></tr></table></figure>
<p><code>fmap</code>은 몇줄만으로 구현할 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.fmap = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fut = <span class="keyword">new</span> Future();</span><br><span class="line">  <span class="keyword">this</span>.ready(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    fut.complete( fn(val) );</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> fut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>현재 Future가 완료되었을 때 결과로 나온 Future도 완료된다. 그 때 매핑 함수를 적용시킨다.</p>
<p>위의 예제에서는, 파일 내용을 잡고 있는 Future를 내용 길이를 잡고 있는 다른 Future로 변이시켰다.</p>
<p>어디서 들어본 말 같지 않은가? 잘 알고 있는 자바스크립트 Array의 <code>map</code> 메소드와 꽤 비슷하다.
실제로 정확히 같은 개념이다.</p>
<ul>
<li>Array  타입은 여러 값들을 잡고 있는 박스다</li>
<li>Future 타입은 완료될 값을 잡고 있는 박스다</li>
<li>Array.map(...) 은 Array 박스 안의 값들을 변이시켜서, 변이된 값들을 잡고 있는 다른 Array 박스를 돌려준다</li>
<li>Future.fmap(...)은 Future 박스 안의 값을 변이시켜서, 변이된 값을 잡고 있는 다른 Future 박스를 돌려준다</li>
</ul>
<p>Array와 Future 타입 둘 모두 포함되는 <strong>Functor</strong>라는 첫번째 게스트가 등장했다. 일반 함수를 하나
받아서 안에 무엇을 가지고 있든 그것이 변이된 결과를 표현하는 다른 인스턴스를 만들어내는 타입이다.</p>
<ul>
<li>다른 타입을 감싸는 컨텍스트처럼 작동할 수 있는 타입이고</li>
<li>내부에 있는 것을 일반 함수에 적용시킬 수 있다면</li>
</ul>
<p>Array와 Future가 아니더라도 그게 무엇이든간에 그 타입을 <strong>Functor</strong>라고 부를 수 있다.</p>
<p>이제 Future를 다른 Future로 매핑할 수 있다. 이제 일반값을 다루듯이 Future를 직접적으로 다루는
함수를 만들 수 있다는 뜻이다. <code>textF.fmap( c =&gt; c.length )</code>처럼 호출하는 대신에 Future를
직접 다루는 <code>lengthF</code>라는 특별한 종류의 함수를 만들 수도 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lengthF: Future&lt;String&gt; -&gt; Future&lt;Number&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lengthF</span>(<span class="params">strF</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strF.fmap( s =&gt; s.length )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>파일 길이를 읽는 예제를 흔히 보던 방법처럼 다시 작성할 수 있게 되었다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nbCharsF = lengthF( readFileF(<span class="string">'...'</span>) )</span><br></pre></td></tr></table></figure>
<p><code>lengthF</code>를 <em>lift된</em> 함수라고 부른다. Functor같은 _박스 타입_을 다루는 함수를 <strong>lift</strong>한다는
것은 일반값을 다루는 함수를 박스 타입을 다루는 함수로 만든다는 뜻이다. 여기에서는 문자열을 다루는 함수
<code>length(String)</code>를 lift해서 Future를 다루는 함수<code>lengthF( Future&lt;String&gt; )</code>로 lift했다.</p>
<p>일반화된 <code>lift1</code>(인자를 하나만 받아서 lift하는 함수)를 정의해보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future.lift1 = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fut =&gt; fut.fmap(fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>비동기 실행을 일반 함수 실행처럼 만들어주는 간단한 추상 함수다. 위에서 <code>lengthF( readFileF('...') )</code>는
<code>readFileF</code>와 <code>lengthF</code>를 조합해서 비동기 연산을 현재의 흐름을 떠나지 않고 실행할 수 있다.</p>
<h2>인자를 여러개 받는 함수는 어떻게? (두번째 게스트?)</h2>
<p>질문에 대답하기 전에 잠시 기초지식에 대해 생각해보자: Future 박스가 잡을 수 있는 타입에는 뭐가
있을까? Future는 모든 타입에 대해 같은 의미를 가질까?</p>
<p><code>Future&lt;String&gt;</code>의 뜻은 명확하다: 시간이 지난 뒤에 문자열 타입의 값이 발생한다는 뜻이다. 다른
타입들에 이 의미를 확장할 수 있을까? 숫자, 객체, 배열? 그럴듯... 그럼 Future 자체에 대해서는
어떨까? <code>Future&lt;Future&gt;</code>는 무슨 뜻일까? 그러니까 Future의 Future는?</p>
<p>보고 바로 이해할 수 있도록, 디렉토리를 보고 첫번째 파일의 내용을 읽는 간단한 예제를 만들어보자
(간단히 생각하기 위해 내부에 다른 디렉토리가 없다고 가정한다).</p>
<p>Node.js에서는 비동기 함수 <code>fs.readdir</code>을 통해 디렉토리 속 파일들 이름의 배열을 가져올 수 있다.
먼저 이걸 Future식 함수로 만들어보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readDirF: String -&gt; Future&lt; Array&lt;String&gt; &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readDirF</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">new</span> Future();</span><br><span class="line">  fs.readdir(path, (err, files) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 기다리면 곧 실행된다</span></span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    f.complete(files);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>readDirF</code>는 디렉토리 내 파일 이름들의 배열을 기다리는 Future를 뜻한다.</p>
<p>위에서 말한걸 구현하려면 필요한 나머지는</p>
<ol>
<li>Future가 잡고 있는 파일 이름들의 배열을 기다린다.</li>
<li>첫번째 파일명을 가져온다.</li>
</ol>
<p>여기서 <code>fmap</code>을 사용할 수 있을까? Node에서 이걸 실행해보자</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resultF = readDirF(<span class="string">"testdir"</span>).fmap( files =&gt; readFileF( files[<span class="number">0</span>]) )</span><br><span class="line">logF( resultF )</span><br></pre></td></tr></table></figure>
<p>기다리면... 아차</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; slots: [] &#125;</span><br></pre></td></tr></table></figure>
<p>확실히 뭔가 잘못됐다. 콘솔에서 파일 내용이 나오는게 아니라 Future 인스턴스 객체의 내용이 나왔다.</p>
<p>왜냐면 <code>fmap</code>은 매핑 함수의 결과가 무엇이든 받아서 그걸 Future로 잡아 돌려주기 때문이다. 위에서의
매핑 함수는 또다른 Future(<code>readFileF</code>의 결과)를 <code>fmap</code>은 그 Future를 잡는 Future를 만들어
<code>resultF</code>에 보내기만 한다.</p>
<p>하지만 Future는 잡고 있는 Future와 함께 끝나는지 않으므로, <em>속에 있는</em> Future가 완료될 때까지
계속 기다릴 뿐이다.</p>
<p>그래서 이럴 때 필요한 함수를 만들어보자. Future를 리턴하고 끝내는 대신에 속에 있는 Future가 끝날
때까지 기다리는 함수다.</p>
<p>(이중 Future)Future<future>를 그냥 Future로 만들어주는 <code>flatten</code>를 만들어보자.</future></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flatten: Future&lt; Future&lt;Value&gt; &gt; -&gt; Future&lt;Value&gt;</span></span><br><span class="line">Future.prototype.flatten = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fut = <span class="keyword">new</span> Future();</span><br><span class="line">  <span class="keyword">this</span>.ready(<span class="function"><span class="keyword">function</span>(<span class="params">fut2</span>) </span>&#123;</span><br><span class="line">    fut2.ready( <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">      fut.complete(val);</span><br><span class="line">    &#125; );</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> fut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이렇게 하면 원하는 결과를 얻을 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = readDirF(<span class="string">"testdir"</span>)</span><br><span class="line">              .fmap( files =&gt; readFileF(files[<span class="number">0</span>], &#123;encoding: <span class="string">'utf8'</span>&#125;) )</span><br><span class="line">logF( result.flatten() )</span><br></pre></td></tr></table></figure>
<p><code>fmap</code>과 <code>flatten</code>을 따로 부르는 대신에 한번에 부를 수 있게 합쳐보자: 매핑 함수에서 나온 2중
Future를 압축(flatten)하는 두가지 일을 한다. 하는 일 그대로 <code>flatMap</code>이라고 하자
(좀 이상한건 나도 안다).</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.flatMap = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.fmap(fn).flatten();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>개념상으로는 위에서 독립적인 두 연산을 _이어서_하는 것인데, <code>readDirF</code>에서 나오는 파일 이름의
배열을 <code>readFileF</code>에 넘겨준다.</p>
<p>여기에서 두번째 게스트가 등장하는데, Future를 Functor라고 부를 수 있는 것처럼 <strong>Monad</strong>라고 부를
수도 있다. 순서대로 연산할 수 있는 방법에 대한 개념이다. 위에서 <code>flatMap</code>에서처럼, 이전 단계에서의
결과를 다음 단계로 넘겨서 여러 함수를 연이어 연산할 수 있다.</p>
<p>Functor처럼 Monad도 많은 사용법이 있는데, 기술적으로 모든 모나드는 다음을 만족한다.</p>
<ul>
<li>일반값을 <em>Monad식(Monoadic) 값</em> 으로 lift하는 방법: 예를 들어, <code>Future.unit</code>은 일반값을 Future로 만든다.</li>
<li>연이은 연산 2개를 이어서 실행하는 방법: Monad는 연산을 이어서 실행하게 해주는 방법이 포함된다. 위에서 <code>flatMap</code>은 그냥 Future 하나만 만들고 다음으로 넘어가는게 아니라, 앞의 Future가 끝날 때까지 기다렸다가 넘어가는 방법이 들어있다.</li>
</ul>
<p>위에서 2개의 다른 연산(<code>fmap</code>과 <code>flatten</code>)으로 두번째 인터페이스(<code>flatMap</code>)를 만들 수 있다는
것을 확인했다. fmap 함수를 정의하는 Functor라면 이중 구조를 단순화시켜서 합치는(flatten) 연산이
필요해진다.</p>
<p>이제 처음의 질문으로 돌아가보자, Future들 여러개를 받는 함수를 어떻게 lift할 수 있을까?</p>
<p>다시 파일 예제로 돌아가서, 디렉토리의 모든 파일 내용을 합치려면 이런 코드가 될 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concatF: (Future&lt;String, ...) -&gt; Future&lt;String&gt;</span></span><br><span class="line"><span class="keyword">var</span> resultF = concatF( text1F, text2F, ...)</span><br></pre></td></tr></table></figure>
<p>이건 무슨 뜻일까? 입력받은 Future들이 잡고 있는 각 문자열들을 합친 것을 다시 잡고 있는 Future를
만들어준다. <code>concatF</code>는 입력받은 모든 Future들이 순서대로 처리되도록 기다려야하므로 결과로 나온
Future는 입력받은 모든 Future가 완료될 때 완료된다.</p>
<p>인자 2개를 받는 경우부터 시작해보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn: (Value, Value) -&gt; Value</span></span><br><span class="line"><span class="comment">// lift2: ( (Value, Value) -&gt; Value ) -&gt; ( (Future, Future) -&gt; Future )</span></span><br><span class="line">Future.lift2 = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (fut1, fut2) =&gt; &#123;</span><br><span class="line">    fut1.flatMap( value1 =&gt; </span><br><span class="line">      fut2.flatMap( value2 =&gt;</span><br><span class="line">        Future.unit( fn(value1, value2) );</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>보이는 것과는 별개로 코드의 로직은 꽤 간단하다. 한줄씩 읽어보자면:</p>
<ul>
<li><code>Future.lift2</code>는 &quot;일반값 2개를 다루는 함수&quot;를 받아서 &quot;Future 2개를 다루는 함수&quot;를 리턴한다.</li>
<li>리턴된 (lift된) 함수가 실제로 하는 일은
<ul>
<li>(중첩되어 실행되는) 2개의 연산을 순서대로 <code>flatMap</code>에 넣고</li>
<li>첫번째 연산은 그 자체로 하는게 없지만 <code>value1</code>을 바인딩해서 스코프에 묶어두는 역할을 하고</li>
<li>두번째로 중첩된 연산은 <code>value1</code>과 <code>value2</code>를 <code>fn</code>에 넘긴다.</li>
<li><code>fn</code>은 일반값을 리턴하는데 <code>flatMap</code>은 받은 함수가 Future를 리턴해야하므로 <code>Future.unit</code>을 통해 일반값을 Future로 lift한다.</li>
</ul>
</li>
</ul>
<p>이게 트릭이다: 모든 Future에서 순차적으로 <code>flatMap</code>을 실행해서 모두 끝나길 기다린 다음에 모든
완료값이 한 스코프에 모였을 때 함수를 실행한다.</p>
<p><code>readDir</code> 내부에서 <code>readFile</code>를 실행하는 것처럼 순차 연산으로 설명되는 <em>Monadic</em> 값과는 다르게
여러 인자를 한번에 lift하도록 마지막에 <code>Future.unit</code>를 사용했다.</p>
<p>파일 2개의 내용을 합치기 위한 예제다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> concat2 = Future.lift2( (str1, str2) =&gt; str1+<span class="string">' '</span>+str2 );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> text1 = readFileF(<span class="string">'test1.txt'</span>, &#123;encoding: <span class="string">'utf8'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> text2 = readFileF(<span class="string">'test2.txt'</span>, &#123;encoding: <span class="string">'utf8'</span>&#125;);</span><br><span class="line"></span><br><span class="line">logF( concat2(text1, text2) );</span><br></pre></td></tr></table></figure>
<p>두번째 Future <code>text2</code>가 첫번째의 <code>text1</code>보다 먼저 끝나더라도 <code>text1</code>을 기다리게 되고,
<code>text1</code>이 끝나면 <code>text2</code>는 이미 끝났으므로 바로 함수를 실행한다.</p>
<p>여러 인자를 받는 함수는, 입력들이 언제 끝나는지나 의존성과는 관련없다는 것을 알 수 있다.
이걸 정리하면 다음과 같다.</p>
<ul>
<li><code>fmap</code>이 하나의 연산을 실행하고</li>
<li><code>flatMap</code>은 순차 연산을 실행하지만</li>
<li>여러 인자를 lift하는 함수는 <em>병렬</em> 실행이다.</li>
</ul>
<p>위에서 봤듯이, Future들을 한번에 실행하고 연산이 진행되기 전에 이미 그 결과를 기다리고 있다.</p>
<p><code>lift2</code>의 패턴을 <code>lift3</code>이나 <code>lift4</code>로 쉽게 확장할 수 있지만, 인자의 갯수와 관계없이 위에서
나온 중첩과 스코프를 통해 일반화를 구현해볼 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future.lift = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> futArgs = toArray(<span class="built_in">arguments</span>), <span class="comment">// Future 인자들</span></span><br><span class="line">        ctx = <span class="keyword">this</span>; <span class="comment">// 컨텍스트(`this`)를 저장</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bindArg(<span class="number">0</span>, []);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bindArg</span>(<span class="params">index, valArgs</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 현재 Future 인자를 기다린다</span></span><br><span class="line">      <span class="keyword">return</span> futArgs[index].flatMap(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        valArgs = valArgs.concat(val); <span class="comment">// 완료값들을 모은다.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (idnex &lt; futArgs.length - <span class="number">1</span>) ? <span class="comment">// 아직 마지막 Future 인자가 아니라면</span></span><br><span class="line">          bindArg(index+<span class="number">1</span>, valArgs) : <span class="comment">// 다음 인자를 flatMap에 넘기고 기다린다</span></span><br><span class="line">          Future.unit( fn.apply(ctx, valArgs) ); <span class="comment">// 끝까지 오면 모은 완료값들을 함수에 넘긴다</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lift</code>에서는 <code>lift2</code>의 패턴을 재활용했다. 인자가 몇개 들어올지 정확히 모르니 재귀를 통해 전체를
순회(iterate)하고, 완료를 기다렸다가 결과를 계속 넘겨서 모은다.(<code>index</code>번째의 Future를
기다렸다가 완료값을 저장하고, 모든 입력이 완료될 때까지 다음 Future 입력에 이 연산을 반복한다.)
마지막 Future까지 오면 함수를 실행하고 결과를 lift해서 리턴한다.</p>
<p>노트: 'Applicative Functor'라는 자료구조를 통해 n개 인자를 lift하도록 구현할 수 있지만,
그러려면 람다나 커리에 대한 설명을 해야하므로 오늘은 일단 생략하자.</p>
<h2>에러 처리</h2>
<p>위에서 <code>fs.readFile</code>의 에러값을 어떻게 뒀는지 다시 확인해보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFileF</span>(<span class="params">file, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">new</span> Future();</span><br><span class="line">  fs.readFile(file, options, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>실제로 작동하지 않는 코드다. 프로그램 흐름에서 떨어져서 실행중이므로 발생하는 에러를 잡을 방법이 없다.
위의 상황에서 에러는 상위로 전파되며 잡는 핸들러가 없어서 Node.js 전체 프로그램을 중단시킨다.</p>
<p>에러를 잡아 흐름을 고치려고 한다거나 의미있는 메시지를 사용자에게 전달하는게 필요할 수도 있다.</p>
<p>가능한 방법으로는 <code>Future</code>에 <em>실패</em> 의 개념을 붙여서 의미를 확장하는 것이 있다. 아직까지는 Future의
결과에 어떤 의미를 붙이지는 않았지만, 가능한 2가지 결과(완료 혹은 실패)로 Future를 생각해볼 수도 있다.
실패에 대한 경우가 포함되었는지 확인해보자.</p>
<p>먼저, 완료를 알리는 <code>ready</code> 메소드가 있으니 실패를 알리는 메소드를 정의해보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Future</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.slots = [];</span><br><span class="line">  <span class="keyword">this</span>.failslots = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future.prototype.failed = <span class="function"><span class="keyword">function</span>(<span class="params">slot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.hasFailed) slot(<span class="keyword">this</span>.error);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">this</span>.failslots.push(slot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Future가 실패할 때의 메소드도 정의해보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.fail = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.completed || <span class="keyword">this</span>.hasFailed)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"이미 끝난 Future를 실패할 수는 없다!"</span></span><br><span class="line">  <span class="keyword">this</span>.hasFailed = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">this</span>.error = err;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, len=<span class="keyword">this</span>.failslots.length ; i&lt;len ; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>.failslots[i](err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 <code>fmap</code>를 다시 생각해보자.</p>
<p><code>readFileF(...).fmap( s =&gt; s.length)</code> 예제에서 파일이 없을 때에 대한 처리가 없다.
제대로 읽었을 때에 대해서만 변환하기 때문에 아닐 때는 에러와 함께 실패할 것이다. 혹시 변환 중 실패할
경우에도 실패해야한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.fmap = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fut = <span class="keyword">new</span> Future();</span><br><span class="line">  <span class="keyword">this</span>.ready( val =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>        &#123; fut.complete( fn(val) ); &#125;</span><br><span class="line">    <span class="keyword">catch</span>(err) &#123; fut.fail(err); &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.failed( err =&gt; fut.fail(err) );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>flatten</code>은 약간 복잡하다. 안쪽과 바깥쪽의 Future 2개가 있고, 각각 완료될 수도 실패할 수도 있다.
그래서 4가지(2x2) 경우를 다뤄야한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.flatten = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fut = <span class="keyword">new</span> Future();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1- 밖깥 실패 안쪽 실패 =&gt; 결과 실패</span></span><br><span class="line">  <span class="comment">// 2- 바깥 실패 안쪽 완료 =&gt; 결과 실패</span></span><br><span class="line">  <span class="keyword">this</span>.failed( _ =&gt; fut.fail(err) );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3- 바깥 완료 안쪽 실패 =&gt; 결과 실패</span></span><br><span class="line">  <span class="keyword">this</span>.ready( fut2 =&gt;</span><br><span class="line">    fut2.failed( err =&gt; fut.fail(err) );</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4- 바깥 완료 안쪽 완료 =&gt; 결과 완료</span></span><br><span class="line">  <span class="keyword">this</span>.ready( fut2 =&gt;</span><br><span class="line">    fut2.ready( val =&gt; fut.complete(val) );</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>flatten</code>에서 안쪽과 바깥쪽 모두 완료되었을 때만 결과가 완료된다.</p>
<p><code>flatMap</code>과 <code>lift</code>는 수정할 필요가 없다. 이미 <code>fmap</code>과 <code>flatten</code>의 의미를 가져오는 것이기
때문에 자동으로 에러에 대한 의미가 추가된다.</p>
<p>자, 이제 실패한 Future들은 연산에서 제외하게 만들었다. 그럼 실패한 Future들을 어떻게 다뤄야할까?</p>
<p>Future 에러를 <em>잡아서</em> 고치면 된다. 어떻게? 실패한 Future를 완료값으로 변이시켜서 원래의 연산에
포함시키면된다.</p>
<p><code>fmap</code>과 비슷하지만 좌우반전같은 <code>fmapError</code> 함수를 만들 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.fmapError = funciton(fn) &#123;</span><br><span class="line">  <span class="keyword">var</span> fut = <span class="keyword">new</span> Future();</span><br><span class="line">  <span class="keyword">this</span>.ready( val =&gt; fut.complete(val) );</span><br><span class="line">  <span class="keyword">this</span>.failed( err =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>         &#123; fut.complete( fn(err) ); &#125;</span><br><span class="line">    <span class="keyword">catch</span>(err1) &#123; fut.fail(err1); &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> fut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fmapError</code>는 <code>catch</code>문의 비동기 버전처럼 작동하며, 정상적으로 완료되면 그냥 값을 넘기고 에러가
발생했을 때는 매핑 함수에 적용시켜서 완료값으로 넘긴다.</p>
<p>간단히 예제를 만들어보자</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readFileF(<span class="string">'unknown file'</span>).fmapError( err =&gt; <span class="string">'alternate content'</span>)</span><br></pre></td></tr></table></figure>
<p>그럼 에러를 Monad식으로 파이프라인처럼 다음 연산으로 넘기려면?</p>
<p><code>flatMap</code>의 좌우반전같은 <code>flatMapError</code>를 만들어보자</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.flatMapError = funciton( fn )&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.fmapError(fn).flatten();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>예를 들어서 어떤 주소(URL)에서 내용을 가져오려고 할 때 요청이 실패한다면 다른 주소에서 가져오도록
시도를 하려고 하는데, <code>flatMapError</code>을 사용해서 앞의 실패를 잡아서 다른 요청을 만들 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resultF = requestF(<span class="string">'/url1'</span>).flatMapError( err =&gt; requestF(<span class="string">'/url2'</span>) )</span><br></pre></td></tr></table></figure>
<p><code>resultF</code>는 첫번째 요청이 성공할 때 <code>'url1'</code>의 내용을 잡고 있고, 실패할 때는 <code>'url2'</code>를
요청해서 그 결과를 잡고 있다는 뜻이다.</p>
<h2>부수효과</h2>
<p>합성해서 연산할 수 있는 방법에 대해 필요한 것들을 모두 다뤄보았다. 지금까지 다뤘던 함수들을 통해서
Future를 동기 연산을 할 때처럼 일반값으로 넘겨서 비동기 처리를 하게 해봈다.</p>
<p>하지만 연산들은 끝까지 도달해야 결과가 나온다. 부수효과가 필요한 연산들을 다뤄 볼 시간이다. UI를
업데이트한다거나 콘솔에 로그를 찍는다거나 데이터베이스에 저장을 한다거나.</p>
<p><code>ready</code>와 <code>failed</code> 이벤트를 사용할 수도 있지만 좋은 방법은 아니라고 생각한다.</p>
<p>실제 어플리케이션에서 한 Future가 여러 자식 Future들을 가지고 그 Future들은 또 자식 Future들을
갖게 되는 트리같은 구조가 된다. Future하나가 완료돌 때 매핑된 Future들이 연쇄적으로 완료된다.</p>
<p>Future의 <code>ready</code>알림을 통해서 부수효과를 실행하려고 한다면 트리 내부에 있는 Future들 전체에
영향을 끼치게 된다. 의미적으로나 구현상으로나 업데이트가 끝날 때까지 부수효과 연산을 미뤄두는 것이 좋다.
예를 들어 DOM을 업데이트할 때는 <code>requestAnimationFrame</code>같은 스케쥴러에 맡기는게 더 좋을 수도 있다.</p>
<p>위에서 말한 이유로 <code>do</code>라는 메소드를 하나 만들텐데 부수효과 연산을 명시하는 것이다. <code>fmap</code>처럼
부수효과 함수를 받겠지만, 내부의 알림들(<code>ready</code>와 <code>failed</code>)이 완료될 때까지 지연될 것이다.</p>
<p>예를 들어</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestF(<span class="string">'/url'</span>).do( val =&gt; <span class="comment">/* update ... */</span> )</span><br></pre></td></tr></table></figure>
<p>이번에도 <em><code>do</code>의 의미와 리턴값이 무엇인지</em> 생각해보자.</p>
<p>변이없이 그냥 Future를 리턴한다면 <code>future.fmap( Id )</code>(여기에서 <code>Id</code>는 <code>x =&gt; x</code> 같은 항등함수)
와 같은 형태이다. <code>fmap</code>과 다른 점은, 먼저 <code>do</code>에서 부수효과가 발생한다는 점이고 두번째는 다른
컨텍스트에서 실행된다는 점이다.(<code>fmap</code>은 즉시, <code>do</code>는 나중에). 가장 다른건 _의미_다.</p>
<blockquote>
<p>정정: 2015년 4월 6일. <code>Action</code>이라는 새로운 타입을 통해 <code>do</code>를 적용했는데, 굳이 Monad(Future)
안에 다른 Monad(Action)을 넣어 복잡하게 만들 필요가 없었다. 서버에 데이터를 넘기거나 응답을
기다리는 등의 상황에서 리턴값이 필요할 수도 있는데, 다음 글에 이걸 개발해 볼 수도 있다.</p>
</blockquote>
<p>빠르게 대충 구현해보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.do = funciton(action) &#123;</span><br><span class="line">  <span class="keyword">var</span> fut = <span class="keyword">new</span> Future();</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.completed) &#123;</span><br><span class="line">    action(<span class="keyword">this</span>.value);</span><br><span class="line">    fut.complete(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.actions.push( val =&gt; &#123; </span><br><span class="line">      action(val);</span><br><span class="line">      fut.complete(val);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future.prototype.complete = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> me = <span class="keyword">this</span>;</span><br><span class="line">  setTimeout( () =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, len=me.actions.length ; i&lt;len; i++)</span><br><span class="line">      me.actions[i](val);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>덧붙여서, 비동기실행을 제대로 구현하려면 process.nextTick이나 MessageChannel 등을 사용해야
하지만 여기서는 간단히 구현하고 넘어가자. 비슷하게, 부수효과의 실패에 대응해 <code>doError</code>도 만들어야
하는데, <code>do</code>와 비슷하므로 각자 알아서 구현해보자. (<a href="https://gist.github.com/yelouafi/40aeb2a70a368acb6e45" target="_blank" rel="external">Gist에 코드 전체가 있다</a>)</p>
<hr>
<p>역주 1: Promise와의 비교는 Future/Functor/Monad 개념을 이해하는데 관계없다고 생각해서 생략했다.</p>
<p>역주 2: <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="external">그림으로 설명하는 Functor, Applicative, Monad</a>(<a href="http://netpyoung.github.io/external/functors_applicatives_and_monads_in_pictures/" target="_blank" rel="external">번역</a>)과 함께 읽으면 이해하는데 도움이 될 것이다.</p>
]]></content:encoded>
      <comments>http://seoh.github.io/blog/2015/05/28/callback-to-future-functor-applicative-monad/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[번역, 스칼라로 전환]]></title>
      <link>http://seoh.github.io/blog/2015/01/18/transitioning-to-scala/</link>
      <guid>http://seoh.github.io/blog/2015/01/18/transitioning-to-scala/</guid>
      <pubDate>Sun, 18 Jan 2015 13:21:37 GMT</pubDate>
      <description>
      <![CDATA[
Translation of &quot;Transitioning to Scala&quot; into Korean, under the same license as the original.

2011년 말부터 2014년 초까지 전자상거래 솔루션 전문 에이전시, Nurun Toronto에서 리드개발자로 일했다. 자바와 스프링만으로 새로운 프로젝트들을 계속하다보니]]>
      </description>
      <content:encoded><![CDATA[<blockquote>
<h3>Translation of &quot;<a href="https://medium.com/p/d1818f25b2b7" target="_blank" rel="external">Transitioning to Scala</a>&quot; into Korean, under the same license as the original.</h3>
</blockquote>
<p>2011년 말부터 2014년 초까지 전자상거래 솔루션 전문 에이전시, <a href="https://www.nurun.com/en/careers/toronto/" target="_blank" rel="external">Nurun Toronto</a>에서 리드개발자로 일했다. 자바와 스프링만으로 새로운 프로젝트들을 계속하다보니 대체제를 찾아야할 때라는걸 알게 되었다.</p>
<p>에이전시에서의 업무를 장기적인 관점에서 생각해봤다. &quot;자바가 구리다&quot;를 이해하지 못하는 고객들 때문에 마감에 시달렸다. 2004년도에 어플리케이션을 만들던 툴과 테크닉들은 2014년에는 별 도움이 되질 않았다. 2004년에는 코드 한줄을 테스트하기 위해 서버를 재시작하는게 당연했다 - 웹스피어는 재시작할 때 정체불명의 1200줄 XML 설정파일을 읽어오는데, 평균 걸리는 시간이 커피 한잔 마시고 오기 딱 좋은 120초 정도다. 요새는 이렇게 하면 에이전시나 개발자나 망한다.</p>
<p>우리가 만드는 어플리케이션들은 단순히 데이터베이스의 뷰어가 아니라, 매일매일 똥을 치워주는 소중한 도구다.</p>
<h3>1. 왜 타입세이프의 스택을?</h3>
<p>지난 프로젝트를 루비온레일즈로 진행해보고 뭘 싫은지를 알았다. 다른 동적 타입 언어도 인터프리트 언어도 상태기반 웹 프레임워크(stateful web framework)도 쓰기 싫었다. 자바 바이트코드로 컴파일되는 정적 타입 언어나 활발한 생태계를 가진 툴들, 그리고 확장성을 위한 무상태 웹 프레임워크가 더 괜찮았다. 또한 우리 고객사들은 믿을만한 회사를 통해 전문적인 기술지원을 받을 수 있어야 마음의 위안을 가졌다.</p>
<p>그래서 몇가지 선택지를 꼽아봤는데, 가장 먼저 타입세이프가 떠올랐다. 우리가 원하는 모든 것들이 있었다.</p>
<p>컨셉증명을 위해 초소형 전자상거래 사이트를 내부적으로 만들어서 스칼라의 단순함과 플레이의 개발 생산성에 대해서 시연했고 충분히 관심을 끌어서 결국 <a href="http://walmart.ca/" target="_blank" rel="external">월마트 캐나다</a>의 새로운 전자상거래 플랫폼의 토대가 되었다.</p>
<h3>왜 스칼라가 복잡하다고 느낄까?</h3>
<p>스칼라는 <em>유연하다</em>. 유연하다는 것은 단순하다는 것을 포기해야하는 일이지만, 다른 면으로 스칼라는 단순히 &quot;자바보다 나은&quot; 정도가 아니라 그보다 더 좋으며 매우 우아한 언어이다. 스칼라나 새로운 어떤 언어로의 전환이라는 큰 도전은 단지 기술적인 일만이 아니다. 능력있는 개발자라면 새로운 문법, 새로운 개념, 새로운 IDE를 배울 수 있다. 변화는 기술보다는 그 과정이나 문화같은 다른 면에서 어렵다.</p>
<blockquote>
<p>짧게 말해서, 모든 것은 사람에 달려있다.</p>
</blockquote>
<p>이 글의 뒷부분은 스칼라 프로그래밍 튜토리얼이 아니다. 이미 많은 글들이 있고, 고급 스칼라의 깊은 부분에 대한 최신 트릭을 가르칠 만큼 나는 인정받은 스칼라 개발자도 아니다. 이 뒤로는 스칼라로의 전환을 생각하고 있는 개발자들, 팀장 혹은 매니저들에게 전하는 조언들이다. 이 조언들은 기업용 스칼라 프로젝트를 이끌 때 개인적으로 한 경험을 토대로한 것들이다.</p>
<h3>스칼라로의 전환을 생각 중인 매니저와 개발자들에게 하는 조언</h3>
<figure>
<img src="/blog/images/transitioning-to-scala/1.jpg"><figcaption class="image-caption">스칼라, 커피 한잔보다 좋다!</figcaption>
</figure>
<h3>1. 언어의 기능들을 이해해라</h3>
<p>모든 스칼라 개발자, 팀장, 매니저는 마틴 오더스키의 <a href="http://www.scala-lang.org/old/node/8610" target="_blank" rel="external">스칼라 레벨 가이드</a>를 읽어야한다.</p>
<p>전업 스칼라 개발자로 경력 1년반이 지나고 엔터프라이즈 스칼라 프로젝트도 진행했지만, 마틴의 가이드에서 스칼라 개발자 등급 A2.5/L1.5라고 생각한다. A3/L3에 있는 테크닉들을 사용하지만, 웹 어플리케이션을 쭉 개발해오면서 대부분은 써본 적이 없다. 케이크 패턴을 써본 적도 없고, 고계도 타입(high-kinded type, 역주: <a href="http://twitter.github.io/scala_school/ko/advanced-types.html#higher" target="_blank" rel="external">스칼라 학교</a>에서는 <em>상류 타입</em>이라고 번역했는데, 하나의 Layer 위에 있다는 생각으로 고계高階를 생각해봤다)을 써본 적이 아직 없다. 그렇다고 나쁜 개발자도 아니고, <a href="http://ko.wikipedia.org/wiki/%EA%B0%80%EB%A9%B4%ED%98%84%EC%83%81" target="_blank" rel="external">가면현상</a>의 증상도 아니고, 단지 내 시간은 한정되어있고 가장 돈이 되는 것에 집중하려고 한다. 게다가 드럼도 치고 기타도 치고 일주일에 두번 댄스 레슨도 다니고 커피도 많이 마시고 데이트하러 나가야한다. 시간은 소중하니까.</p>
<p>Walmart.ca 프로젝트에서는 콤비네이터 파서와 폴드를 사용하지도 않고 레벨 가이드의 얇은 부분만을 썼다. &quot;얇은&quot; 스칼라로도 이전 플랫폼보다 훨씬 좋은 생산성을 보여줬다. 구현하는데 골치아픈 일도 없었다. 그렇게 짠 코드들은 이전보다 더 관리하기에도 좋고 생산성도 더 좋았다. 블랙 프라이데이나 박싱 데이(역주, 북미지역 등지에서 추수감사절 시즌/크리스마스 시즌에 대부분의 쇼핑몰들이 매년하는 대량할인 이벤트 기간들)에서의 확장도 완벽하게 돌아갔고, 많은 자바기반의 전자상거래 플랫폼은 하지 못했던 것들이다.</p>
<p>그래서 중요하지 않다는건가?</p>
<p>단순하게 스칼라를 쓴다는 것을 스칼라가 부족하다는 것으로 착각하지 마시길. A1과 A2 등급에서 익힐 수 있는 것들을 보자.</p>
<ul>
<li>간단한 클로저</li>
<li>map, filter 등의 콜렉션</li>
<li>패턴 매칭</li>
<li>trait 합성</li>
<li>재귀</li>
<li>XML 표현식</li>
</ul>
<p>(역주: 코멘트에서 XML 표현식은 <a href="http://www.swift.com/" target="_blank" rel="external">SWIFT</a>에서 사용중이라고 한다.)</p>
<p>자바에 몇개 더 추가한 것과 비슷하다. 서술하듯이 개발하고 소프트웨어를 관리하는 새로운 방법이다. A3에 있는 몇개도 익히기 꽤 쉽고 - Akka나 다른 병렬 처리 라이브러리들을 사용하기 위해 꽤나 중요한 것들인데 - 그에 비해 크게 어렵지 않고 수학 학위가 필요할 정도는 아니다.</p>
<ul>
<li>fold</li>
<li>stream, 혹은 지연평가 자료구조</li>
<li>actor</li>
<li>combinator parser</li>
</ul>
<p>이런 테크닉들을 익혔을 때의 좋은 부가효과는, 사용하는 <strong>모든</strong> 언어에서 더 좋은 개발자가 된다는 것이다. 나는 스칼라와 자바스크립트 모두에서 클로저나 다른 테크닉들을 익히는데 정말 도움이 됐고 더 좋은 자바스크립트 프로그래머가 되었다.</p>
<h3>2. 시간을 써라</h3>
<p>자바에서 건너온 많은 스칼라 개발자들은 바로 적응하고 싶어하지만 스칼라는 완전히 다른 언어다. 새로운걸 익힌다는 것은 연습을 필요로 한다. 스칼라도 예외는 아니다.</p>
<p>좋은 소식은 A2/L1 등급만으로도 충분히 스칼라 어플리케이션을 만들만한 자격이 있다는 것이다. 모든 스칼라 개발자가 고급 순수함수 자료구조, 타입 이론, 고계도 타입을 이해하고 있을 필요는 없다. 하지만 스칼라는 차세대 어플리케이션을 만드는 전문 개발자를 위한 프로그래밍언어라는 것이다. 그래서 배우고 체득하는데 많은 시간이 걸릴 것이다.</p>
<p>###3. 배우는걸 두려워말라</p>
<p>자바 개발자라면 다음과 같은 자료들을 통해 스칼라를 배우길 강력히 추천한다.</p>
<ul>
<li><a href="http://www.amazon.com/Scala-Impatient-Cay-S-Horstmann/dp/0321774094" target="_blank" rel="external">Scala for the Impatient</a>를 읽어라. 특히 <em>예제</em>가 필요한 성격급한 개발자들에게 좋은 시작점이다. (역주, 번역판 <a href="http://www.bjpublic.co.kr/skin12/product_list.php?boardT=v&amp;page_idx=9&amp;goods_data=aWR4PTk2JnN0YXJ0UGFnZT0zNiZsaXN0Tm89NjEmdGFibGU9cmVkX2dvb2RzJnBhZ2VfaWR4PTkmc2VhcmNoX2l0ZW09%7C%7C" target="_blank" rel="external">쉽게 배워서 빨리 써먹는 스칼라 프로그래밍</a>, 2013 비제이퍼블릭)</li>
<li>마틴 오더스키, 렉스 스푼, 빌 베너스의 <a href="http://www.amazon.com/Programming-Scala-Comprehensive-Step---Step/dp/0981531644" target="_blank" rel="external">Programming in Scala</a>를 읽어라. <em>Scala for the Impatient</em>보다 더 자세한 책이라 언어의 기능들에 대해 폭넓은 시야를 익히기에도 좋다. (역주, 번역판 <a href="http://www.acornpub.co.kr/book/programming-in-scala" target="_blank" rel="external">Programming in Scala</a>, 2014 에이콘)</li>
<li>가능하면 Coursera의 <a href="https://www.coursera.org/course/progfun" target="_blank" rel="external">Functional Programming Principles in Scala</a> 코스를 들어라. Coursera가 Scala로 만들어졌다.</li>
<li><a href="https://typesafe.com/activator" target="_blank" rel="external">Typesafe Activator</a> 템플릿들을 살펴봐라. 다른 언어들에 비해 온라인 문서나 학습자료가 부족하기도 하지만, 다른 사람 코드를 분석하는게 제일 좋은 방법이기도 하다. 특히 James Ward같은 능력있는 개발자들이 짠 코드라면.</li>
<li>가능하면 Coursera의 <a href="https://www.coursera.org/course/reactive" target="_blank" rel="external">Principles of Reactive Programming</a> 코스를 들어라. 스칼라와 대량 데이터 처리를 위한 Akka를 사용하려는 개발자들에게 좋은 자료다.</li>
<li>스칼라 모임에 참석하고 스칼라를 사용하는 실무자들이 어디에 쓰는지 배워라.</li>
<li><a href="http://www.amazon.com/Functional-Programming-Patterns-Scala-Clojure/dp/1937785475" target="_blank" rel="external">Functional Programming Patterns in Scala and Clojure</a>를 읽어라. 예전의 명령형 스타일 코드와 더 읽을만해진 함수형 스타일 코드를 비교해보고 더 함수형의 언어를 배우고 싶어졌다. 하스켈은 좀 과하고, 그래서 Clojure를 배우기 시작했다. 그리고나서 내 스칼라 코드는 더 간략해지고 더 의미있어졌다.</li>
</ul>
<h3>4. 온라인에서 읽는 것들은 적당히 감안해서</h3>
<p><a href="https://github.com/scalaz/scalaz" target="_blank" rel="external">Scalaz</a>를 만든 <a href="http://blog.tmorris.net/" target="_blank" rel="external">토니 모리스</a>처럼 다른 세계에서 온 똑똑한 개발자들이 많이 있다. 하스켈 세계나, 함수형 프로그래밍, 그리고 수학 분야.</p>
<p>토니는 다음과 같은 함수 선언에 반대를 한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span>[<span class="title">A</span>]:</span> List[A] =&gt; List[A]</span><br></pre></td></tr></table></figure>
<p>그리고 이런 선언을 더 선호한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> &lt;-:</span>[A, B](f: A =&gt; B): List[A] =&gt; List[B]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>다음에 &lt;-:라는 이름의 함수를 보면 이렇게 생각해라, &quot;으악, 읽기도 구리고 내가 뭘 하고 있는거야?&quot;, (아마 친근보다는 좀 강력한) 다른 툴은 없는지? 이거 타입은 뭐지? 대수적인 속성은 뭐지? 드러난 속성들이 또 뭐가 있지?</p>
<p><a href="http://blog.tmorris.net/posts/identifier-names/index.html" target="_blank" rel="external">Sticks, stones, but names are not useful to me</a> by Tony Morris</p>
</blockquote>
<p>이게 스칼라의 미학이다. 토니도 맞다. 틀린건 없고, 그냥 개인과 팀의 선택에 대한 문제다. 나는 &lt;-:보다 <strong>reverse</strong>를 더 선호하지만, 내가 가독성과 단순성을 선호하는만큼 토니같은 개발자들은 수학적인 순수성과 사실성을 선호한다. 이 스타일들은 항상 다른 것 같다. 토니는 라이브러리들을 개발했고, 나는 라이브러리들로 어플리케이션을 만들고, 우리 둘 다 스칼라로 개발한다. 나는 가끔 <em>var</em>를 쓰고 나중에 걷어내지만, 누군가는 그걸 질색한다.</p>
<p>그런데 팀에서 사람들이 영어, 불어, 독어 같이 한 언어가 아닌 여러 언어를 쓴다고 해보자. 이럴 때 함수 이름을 영어 동사로 써도 그러려니 한다. 내가 같이 일했던 캐나다 사람들은 영어와 불어를 쓰는 사람들이 많았고, 헝크러진 머리나 좁쌀만한 눈(역주, 미국인이 캐나다인을 놀릴 때 주로 쓰는 표현)보다는 보기 괜찮다고 확신할 수 있다. 젠장(<em>Sacré bleu!</em>)</p>
<p>스칼라처럼 독선적이지 않은 언어는 그래서 아름답다. 자기 스타일을 자유롭게 적용할 수 있고, 언어가 그걸 방해하지 않는다. &lt;-:도 <em>쓸 수 있다는</em>게 마음에 든다.</p>
<h3>5. 주머니가 허락한다면 기술지원을 받아라</h3>
<p>나는 운좋게도 타입세이프의 Nilanjan Raychaudhuri와 Roland Kuhn같은 진짜 고수들에게 배워서 Nurun에 설계 리뷰, 코드 리뷰, 페어 프로그래밍을 도입할 수 있었다. 새로운 프로그래밍 스타일을 배운 덕분에 신뢰도를 월등히 높인 프로젝트를 진행하면서 다방면으로 값으로 따질 수 없는 도움을 받았다.</p>
<p>단순히 스칼라의 함수형 스타일뿐만 배운게 아니라, 리액티브 프로그래밍 컨셉도 배웠다. Play와 Akka도. 새로운 테크닉들과 프로젝트 전반에 걸쳐 타입세이프의 도움을 많이 받았다. 우리가 항상 제대로 된 길을 가고 있는지에 대해 확신을 받았다.</p>
<p>타입세이프의 이메일 지원 역시 훌륭하다. <a href="http://typesafe.com/how/subscription" target="_blank" rel="external">지원 구독</a>은 주머니가 허락한다면 지출할 가치가 충분히 있다.</p>
<h3>6. 다양성을 포용하라</h3>
<p>스칼라 커뮤니티에는 전세계의 다양한 프로그래머들이 모여있다. 나처럼 전직 자바 개발자도 있고, 학계에서 온 사람들도 있다. 독학한 개발자도 있고 박사학위자들도 있다. 빠듯한 예산으로 사업문제를 해결하려 하는 사람들도 있고, 관심분야를 넓히려고 하는 사람들도 있다. 어플리케이션을 만드는 사람도 있고, 라이브러리를 만드는 사람도 있다.</p>
<p>커뮤니티의 모든 사람을 존중하고 이해하는게 좋은 개발자가 되는데 중요하다. StackOverflow에 단순한 질문을 올렸는데, 이해하려면 카테고리 이론을 몇년 배워야하는 난해한 답변이 달릴지도 모른다. 하지만 스칼라는 아직 새로운 언어이고 커뮤니티는 자기 색깔을 찾아가고 있다는 것을 염두에 둬라. 학계 출신이 아닌 개발자들이 스칼라 세계에 더 많아지고 더 많이 답변하다보면 토론은 조금 더 <em>이론</em> 개념보다는 <em>어플리케이션</em> 개념으로 옮겨갈 것이다.</p>
<p>답변에 실망했다면, 트위터의 <a href="https://github.com/twitter/finagle" target="_blank" rel="external">Finagle</a>이나 mDialog의 <a href="https://github.com/mDialog/smoke" target="_blank" rel="external">Smoke</a>같은 라이브러리들의 소스코드를 봐라. 두 프로젝트는 제품 레벨에서도 많이 쓰이는 구현체로 훌륭한 스칼라 예제이다. 모든 스칼라가 어마어마하게 복잡하지는 않다.</p>
<h3>7. 현실적인 목표를 설정하라</h3>
<p>자바에서 온 신입 스칼라 개발자들은 하룻밤만에 고급 스칼라, 함수형 스칼라를 배울 수 없다는 사실을 깨달아야한다. 전형적인 비지니스 어플리케이션을 성공적으로 개발하는데 고급 함수형 스칼라가 필요한건 아니다.</p>
<p>함수형 프로그래밍을 접해본 개발자라면 스칼라 스타일로 익히데 시간이 덜 걸릴 것이다. 그렇지만 팀원들 대부분이 명령형 언어 개발자들이라면 스타일을 맞춰야할 것이다.</p>
<p>그리고 팀 밸런스에 대한 것인데, 유지보수해야할 사람이 이해할 수 있는 코드를 짜야할 것이다. 아무리 전세계에서 가장 우아한 코드라도 관리할 수 없으면 쓸모없다.</p>
<h3>8. 짝코딩과 코드리뷰는 의무</h3>
<p>짝코딩을 하면 팀 전체 스타일과 기술 평균에서 너무 멀어지지 않게 해주는데 효과적이다. 마지막으로 바라는게 필멸자들이 감히 범접할 수 없는 어려운 코드를 짜거나, 팀원들이 다들 준비가 될 때까지 다시 완벽하게 작동하는 명령형 코드로 짜는 것이다. 실험은 중요하지만, git은 두었다 무엇하는가. 포크해라, 두번해라.</p>
<figure>
<img src="/blog/images/transitioning-to-scala/2.png"><figcaption class="image-caption">팀원들이 이렇게 된다</figcaption>
</figure>
<p>스칼라의 유연성 덕분에 복잡함의 칼날을 피하는 것도, 언어의 새 기능이나 스칼라의 표현력을 익히기 쉽다. 문화는 언제나 개발팀에게 중요하지만, 더 중요한건 스칼라를 처음 배울 때 다같이 페달을 밟아 나가야한다는 것이다.</p>
<h3>9. 간결함을 유지하라</h3>
<p>스칼라는 새로운 것이고, 사람들은 무엇을 써야하고 무엇을 피해야할지 여전히 배우는 중이다. 더글라스 크록포드가 스칼라를 마스터하고 <em>Scala: The Good Parts</em>를 쓰기 전까지는, 언어의 각 부분에 대한 가치를 알아서 확인해야한다. 옳고 그름은 없고, 단지 시도와 실패만 있을 뿐이다. 뭐가 더 맞는지에 대해 얼마든 질문해라.</p>
<p>Reflection API가 처음 자바에 도입되었을 때, 모든 자바 개발자들이 자신들의 지적 능력을 동원해 <strong>모든 것</strong>에 리플렉션을 사용하려고 했다. 당시 내가 개발하던 코드들은 관리하기가 더럽게 복잡해졌고, 한 개발자가 미쳐날뛰어서 이해하지 못하는 기능을 남용했다는 것 말고 다른 이유는 없었다. 모든 생소한 기능은 발을 담그기 전에 천천히 깨끗하고 심플한 코드를 짜는게 더 낫다. 고급 테크닉을 이상하게 뒤죽박죽으로 구현한 것보다 깔끔하게 명령형 스타일로 스칼라 코딩을 하는게 차라리 낫다.</p>
<figure>
<img src="/blog/images/transitioning-to-scala/3.jpg"><figcaption class="image-caption">준비가 되기 전에 깊게 들어가지마라. 천천히 가자.</figcaption>
</figure>
<p>좋은 음악처럼 좋은 코드도 우아하고 드물다. 좋은 음식에 꼭 좋은 재료가 들어가는건 아니다. 상상할 수 있는 모든 향신료가 들어간 음식을 먹고 싶어할 사람이 있을까? 코드를 쓰는 것도 그렇다. A1급 개발자가 쓴 신뢰할만한 코드는 자기가 뭘 하고 있는지 왜 하는지도 모르며 제멋대로 짠 A3/L3급 개발자의 코드보다 더 관리하기 쉽다.</p>
<h3>10. 구린 코드를 살펴봐라</h3>
<p>심각하게 구린 스칼라 코드를 짤 수도 있고, 자바, 펄, 그리고 영어도 마찬가지다.</p>
<p>하지만 구린 자바코드와 구린 스칼라코드의 중요한 차이가 있다.</p>
<p>구린 스칼라 코드는 좀 다른 방식으로 구리다. 명령형으로 구리거나, 함수형으로 구리거나, 혹은 두가지가 섞인 채로 구리거나. 이해할 수 없을 정도로 구리다면 익숙하지 않은 스타일이라서 그럴 수도 있다. 스칼라는 새로운 언어라, 자바같은 성숙된 언어처럼 바로 안티패턴을 발견해내는게 아직은 어렵다. 그래서 개발팀들이 아름다운 코드를 구리다고 착각할 수도 있고, 구린 코드를 아름답다고 착각하게 될 수도 있다. 개발자들은 배운대로 구린 패턴을 짜기 시작하면 나중에는 더 구린 코드가 나온다. 그렇게 악순환이 된다.</p>
<p>나중에 고치려고 하는 것보다 처음부터 피하는게 더 좋다.</p>
<p>똑똑한 개발자가 스칼라로 이상하게 코딩한다면 불러봐라. 질문해라. 익히지 못한 언어에 대해 추측하지마라. 최악의 경우는, 잘못짰으면서 우아한 코드라고 생각은 하는데, <em>왜</em> 우아한지 이해하지 못하는 경우다.</p>
<h3>11. 스칼라는 단지 퍼즐의 일부분</h3>
<p>웹 어플리케이션을 개발하는 방법은 10년전에 비하면 매우 다양하다. 요새는 스칼라, 플레이, AngularJS, MongoDB 앱을 개발한다. 내가 짜는 코드 대부분은 클라이언트단이다. 몇년간은 스칼라보다 Angular를 더 많이 짰는데, 나쁘다는게 아니라 그냥 현실이 그렇다.</p>
<p>스칼라의 미학은 자바처럼 쓸데없는 밑바닥을 만들어야하거나 루비같은 동적 언어의 불안함을 걱정할 필요없이 깔끔하고 안정적이고 성능좋은 서버단 코드를 짤 수 있게 해준다는 것이다. 스칼라로 짠 서버쪽 로직은 견고하기에 클라이언트쪽 코드를 안정적으로 짜는데 시간을 투자할 수 있다.</p>
<p>스칼라의 모든 쪽에서 마스터가 되고 싶어하는만큼 파고들어야할 기술들이 너무 많다. HTML5, SASS, AngularJS, RequireJS, SQL, MongoDB, 또, 또, 또.</p>
<p>한 언어의 모든 면을 마스터할 시간은 없겠지만, 스칼라는 맛을 보기만 해도 괜찮은 기술이다. <a href="http://www.reactivemanifesto.org/" target="_blank" rel="external">Reactive Programming</a>은 다음 세대의 대세가 될 것이며 그 패러다임 전환의 선두에 스칼라가 있을 것이라 믿는다. 성능과 안정성을 모두 얻을 수 있는 리엑티브 어플리케이션을 무시하기는 힘들다.</p>
<p>요즘엔 대부분 묵직한 XML 대신 JSON을 쓴다. SOA 패턴 대신 REST를 쓴다. 데스크탑 대신 모바일을 쓴다. 어마어마한 크기의 데이터에서 필요한 정보를 뽑아낼 때, Akka의 성능이라면 막대한 하드웨어를 투자하지 않고서도 가능하다.</p>
<p>스칼라는 퍼즐의 한 부분일 뿐이지만, 새로운 종류의 개발을 위해 필요한 다른 많은 부분들의 심장과도 같다.</p>
<h3>12. 스칼라를 배우면 더 좋은 프로그래머가 된다</h3>
<p>직장인 개발자가 자기 영역을 넓히는건 <em>정말</em> 드문 일이다. 소프트웨어 개발에서 완전히 다른 접근법을 배워본게 마지막으로 언제인가?</p>
<p>마지막 전환(그리고 내 경력에서 겪었던 유일한 전환)은 절차지향 언어에서 객체지향 언어로의 변환이었다. CIBC에서 인턴하던 1998년에 운좋게도 첫 자바 어플리케이션 개발자 중 하나가 될 수 있었다. 대부분의 개발자들은 전직 COBOL이나 C였다가 전환하는 시점이었다. 요새는 뭐든 다 자바를 쓰지만, 당시에 윈도우와 OS/2에 모두 배포해야하는 상황에서 자바는 매우 실용적이었다.</p>
<p>2-30년 경력의 개발자들(몇명은 실제로 펀치카드로 프로그래밍을 해봤던)과 일하면서 좋은 경험을 쌓았고, 한가지 스타일에 매이면 안된다는 것을 깨달았다. 자바를 배울 때 JCL도 관리해야했다. 바로 다시 복귀하기 몇달전까지는 old COBOL과 360 어셈블리도 파고들었다. 넓게 보자. JCL과 COBOL이 섹시한 언어는 아니지만 필요한 분야에서는 괜찮은 언어다. 인턴시절 스몰토크에서 엑셀까지 모든 것을 겪어볼 수 있었다.  엑셀은 처음 접한 함수형 프로그래밍이다. (역주: 엑셀이 함수형 프로그래밍을 지원하는지에 대한 <a href="http://programmers.stackexchange.com/questions/125990/questions-over-excel-programming" target="_blank" rel="external">StackExchange</a>의 글이 댓글에 있다.)</p>
<p>스칼라는 부당한 평을 많이 받았다. 어떤 개발자들은 생각을 깊게 하기보다는 잠깐 시도해보고 익숙한 언어로 도망친다. 문제는 그 사람들이 인터넷에 남긴 불평들 때문에 관심있어하는 개발자들에게 언어의 가치가 잘못 전달될 수도 있다.</p>
<p>스칼라에 대한 불만을 읽는다면 누가 썼는지 찾아보기를. 다른걸 원한 사람일 수도 있다. 쉽게 흔들리지 말고, 불평하는 사람들에게 얽매이지 마라. 점점 널리 퍼져가는 스칼라의 성공사례들을 찾아보기를 바란다.</p>
<h3>결론</h3>
<p>스칼라는 기술뿐만이 아니라 문화적인 투자다. 투자할만한 가치가 있는 보상이 있는데, 어쨋든 해봐야하지 않을까? 확장가능하고 믿을만하고 관리하기 편한 프로젝트를 진행중이라면, 혹은 프로그래머로서 사고를 확장하고 싶다면 단언컨데 스칼라는 할만 하다. 기본만 있으면 보이는 것만큼 어렵지도 않다.</p>
<p>스칼라는 실무에서도 쓸만하다는걸 기억해라, 아니 이미 쓰이고 있다.</p>
<style type="text/css">
.image-caption {
position: relative;
width: 100%;
text-align: center;
left: 0;
margin-top: 10px;
letter-spacing: .01rem;
font-weight: 400;
font-style: italic;
font-size: 14px;
line-height: 1.4;
color: #666665;
outline: 0;
z-index: 300;
}
</style>]]></content:encoded>
      <comments>http://seoh.github.io/blog/2015/01/18/transitioning-to-scala/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[책 후기, Programming in Scala 2nd]]></title>
      <link>http://seoh.github.io/blog/2015/01/18/pis-review/</link>
      <guid>http://seoh.github.io/blog/2015/01/18/pis-review/</guid>
      <pubDate>Sat, 17 Jan 2015 20:31:17 GMT</pubDate>
      <description>
      <![CDATA[
이런 테크닉들을 익혔을 때의 좋은 부가효과는, 사용하는 모든 언어에서 더 좋은 개발자가 된다는 것이다. 나는 스칼라와 자바스크립트 모두에서 클로저나 다른 테크닉들을 익히는데 정말 도움이 됐고 더 좋은 자바스크립트 프로그래머가 되었다.
스칼라로의 전환에서

스칼라를 도전해본 것은 이번이 처음이 아니다. 함수형에 대해 이름만 알던 차에 자바 개발자를 위한 함]]>
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>이런 테크닉들을 익혔을 때의 좋은 부가효과는, 사용하는 <strong>모든</strong> 언어에서 더 좋은 개발자가 된다는 것이다. 나는 스칼라와 자바스크립트 모두에서 클로저나 다른 테크닉들을 익히는데 정말 도움이 됐고 더 좋은 자바스크립트 프로그래머가 되었다.</p>
<p><a href="https://medium.com/@kvnwbbr/transitioning-to-scala-d1818f25b2b7" title="Transitioning to Scala" target="_blank" rel="external">스칼라로의 전환</a>에서</p>
</blockquote>
<p>스칼라를 도전해본 것은 이번이 처음이 아니다. 함수형에 대해 이름만 알던 차에 <a href="http://www.hanbit.co.kr/ebook/look.html?isbn=9788979149678" title="Functional Programming for Java Developers" target="_blank" rel="external">자바 개발자를 위한 함수형 프로그래밍</a>를 읽고 함수형이라는 개념을 더 배우고 싶어했고, 코세라(Coursera)에 가입하게 된 계기이자 처음으로(그리고 현재로서는 마지막으로) 수료한 <a href="https://www.coursera.org/course/progfun" title="Functional Programming Principles in Scala" target="_blank" rel="external">스칼라로 배우는 함수형 프로그래밍 기초</a>로 함수형이라는 패러다임을 잠깐 맛보았다. 그리고 1년 정도 손을 놓았다가 <a href="https://www.coursera.org/course/reactive" title="Principles of Reactive Programming" target="_blank" rel="external">리액티브 프로그래밍 기초</a>에 다시 도전했다가 영어 실력의 한계와 스칼라의 이해가 부족했다라는 점만 뼈저리게 깨닫고 중도포기를 했다. 그리고 <a href="http://www.bjpublic.co.kr/skin12/product_list.php?boardT=v&amp;page_idx=9&amp;goods_data=aWR4PTk2JnN0YXJ0UGFnZT0zNiZsaXN0Tm89NjEmdGFibGU9cmVkX2dvb2RzJnBhZ2VfaWR4PTkmc2VhcmNoX2l0ZW09%7C%7C" title="Scala for the Impatient" target="_blank" rel="external">쉽게 배워서 빨리 써먹는 스칼라 프로그래밍</a>를 통해 문법은 리뷰할 수 있었지만 언어 자체와 함수형에 대한 이해도가 좋아지진 않았다.</p>
<p>스칼라를 더 공부해보고 싶다는 막연한 생각은 가지고 있었고, 함수형에 대한 재미 때문에 underscore/lo-dash를 다양하게 써본다거나 <a href="http://hanbit.co.kr/book/look.html?isbn=978-89-6848-079-9" title="Functional Javascript" target="_blank" rel="external">함수형 자바스크립트</a> 책을 재미있게 읽기도 했고, 파이썬을 다시 써볼까 싶어서 나간 스터디에서 <a href="http://euler.synap.co.kr/" title="Project Euler" target="_blank" rel="external">프로젝트 오일러</a>의 문제를 최대한 함수형으로 풀어보면서 더 간결한 코드 작성이 가능해졌다는걸 느꼈다. 그러던 차에 내가 들었던 두 강의의 교수이자 스칼라를 만든 마틴 오더스키의 책, <a href="http://www.acornpub.co.kr/book/programming-in-scala" title="Programming in Scala" target="_blank" rel="external">스칼라 프로그래밍 2판</a> 번역판이 출간된다는 이야기에 많이 기대하고 있었다. 책 내용과 관련없는 이야기를 길게 늘어놓은 이유는, 내가 생각하기에 나는 초심자와 다름없는 수준같지만 그래도 완전히 스칼라를 처음 접하는 사람과 느끼는 부분이 다를 수 있어서 겪어온 과정을 적어봤다.</p>
<hr>
<p>첫번째 장에서는 스칼라의 특징들에 대한 설명과 어떤 언어에서 어떤 장점들을 가져온 것인지에 대해 나열하며 앞으로 배울 것들에 대해 개요를 보여준다. 하지만 언어론에 대해 관심이 있는 사람이 아니라면 적당히 훑어보고 나중에 다시 읽거나 아니면 구조적인 내용(10장 상속과 구성)이 나오기 전까지 읽고 나서 언어에 대한 감을 잡고 다시 1장을 읽어보기를 권한다. 1장을 (체감상)세 호흡 정도로 읽었다면 2장부터 9장까지는 거의 한 호흡에 집중해서 쭉 읽었다.</p>
<p>2장부터는 필요할 때 REPL로 한줄 정도 테스트해보면서 쭉 읽어나갔다. 그래도 문법에 대해서는 어느 정도 알고 있어서 무난히 넘어가긴 했지만, 이 책으로 처음 스칼라를 접한 사람들에게는 코딩을 시도해볼 여지가 별로 없다. 새로운 언어를 배울 때 이것저것 시도해보면서 체득하는 것이 중요하다고 생각해서 이 책의 그나마 단점이 있다면 그런 면이 아닐까 생각한다. 위에서 언급한 <a href="http://www.bjpublic.co.kr/skin12/product_list.php?boardT=v&amp;page_idx=9&amp;goods_data=aWR4PTk2JnN0YXJ0UGFnZT0zNiZsaXN0Tm89NjEmdGFibGU9cmVkX2dvb2RzJnBhZ2VfaWR4PTkmc2VhcmNoX2l0ZW09%7C%7C" title="Scala for the Impatient" target="_blank" rel="external">쉽게 배워서~</a>의 경우에는 설명이 빈약해서 그 책만으로 스칼라를 이해하기 어렵지만 챕터마다 연습문제가 있어서 이 책을 읽으면서 같이 진행한다면 좋은 부교재가 되지 않을까 싶다.</p>
<h3>추천 챕터</h3>
<p>오랜만에 끝까지 정독한 책이지만 아직 완전히 이해했다고 생각하지 않아서 챕터들에 대해 평가를 내리기 조심스럽지만, 그래도 이 책을 읽을 사람들을 위해서 꼭 두번 읽고 넘어가라고 권해주고 싶은 챕터들이 있어서 메모를 해뒀다.</p>
<ul>
<li>12.7 트레이트냐 아니냐, 이것이 문제로다: 어떨 때 트레이트로 만들어야하는지에 대한 가이드라인</li>
<li>15.1 패턴 매치(p322-324): 패턴매치가 어떻게 작동하는지에 대해 화이트박스로 설명하는 자세한 가이드</li>
<li>16.10 스칼라의 타입 추론 알고리즘 이해: 어떤 순서와 힌트로 타입을 추론하는지에 대한 매카니즘과 현재 불가능한 점.</li>
<li>22.1 List 클래스 개괄: 함수형 언어들에서 List(정확히는 cons 구조)가 왜 중요한지, 그리고 이 구조를 이해해야 지연 평가를 이해</li>
<li>24.15 뷰: Scala를 Scala답게 쓰기 위한 기능(자세히 설명하기 어렵지만 읽고 나면 이해될 것이다)</li>
</ul>
<h3>외부 라이브러리 사용</h3>
<p>그리고 책에서는 <code>scala.actors.Actor</code>가 2.11부터 삭제예정(deprecated)이니 akka를 사용할 것을 권장하고 있는데, 2.11.0부터 아예 패키지 자체가 삭제되었다. 또, 2.11.0부터 독립한 다른 라이브러리들도 있다. <a href="http://www.scala-lang.org/api/2.11.0" title="Scala Standard Library 2.11.0" target="_blank" rel="external">Scala 2.11.0</a> API 페이지를 보면 다음과 같은 부분이 있다.</p>
<ul>
<li>scala.reflect - Scala's reflection API (scala-reflect.jar)</li>
<li>scala.xml - XML parsing, manipulation, and serialization (scala-xml.jar)</li>
<li>scala.swing - A convenient wrapper around Java's GUI framework called Swing (scala-swing.jar)</li>
<li>scala.util.continuations - Delimited continuations using continuation-passing-style (scala-continuations-library.jar, scala-continuations-plugin.jar)</li>
<li>scala.util.parsing - Parser combinators, including an example implementation of a JSON parser (scala-parser-combinators.jar)</li>
<li>scala.actors - Actor-based concurrency (deprecated and replaced by Akka actors, scala-actors.jar)</li>
</ul>
<p>책을 기준으로 akka를 제외하고 28장 XML 다루기(scala-xml.jar), 33장 콤비네이터 파싱(scala-parser-combinators.jar), 34장 GUI 프로그래밍(scala-swing.jar)이 해당된다. 신기한 것은 REPL로 한줄씩 테스트해볼 때는 몰랐는데, scala-xml이 독립했다는걸 보고 이클립스에서 프로젝트로 만들어서 실험해봤더니 XML 표현법(literal)에서 에러가 났다. REPL(<code>scala</code>)의 경우, bash script 파일인데 여기서 기본 라이브러리(homebrew로 설치한 경우 <code>/usr/local/Cellar/scala/2.11.4/libexec/lib</code>)를 classpath로 추가해서 실행되므로 가능한 것이다.</p>
<p>외부 라이브러리를 어떻게 사용하는지에 대해 나와있지 않아서 sbt를 사용해보려고 검색하다가 이 책의 역자인 오현석님께서 번역하신 트위터의 <a href="https://twitter.github.io/scala_school/ko/" title="Scala School" target="_blank" rel="external">스칼라 학교</a>의 <a href="https://twitter.github.io/scala_school/ko/sbt.html" title="Simple Build Tool" target="_blank" rel="external">빌드 도구 SBT(Simple Build Tool)</a> 챕터를 참고해 시도해보려고 했지만, 간단한 의존성 추가에 너무 많은 공수가 들어서 sbt 레퍼런스에서 <a href="http://www.scala-sbt.org/0.13/tutorial/Library-Dependencies.html" title="Library dependencies" target="_blank" rel="external">라이브러리 의존성</a>를 참고해 build.sbt을 작성했다. 예를 들어 akka-actor만 추가할 경우에</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">name :</span>= <span class="string">"Ciruit Simulator"</span></span><br><span class="line"></span><br><span class="line"><span class="string">version :</span>= <span class="string">"0.1.0"</span></span><br><span class="line"></span><br><span class="line"><span class="string">scalaVersion :</span>= <span class="string">"2.11.4"</span></span><br><span class="line"></span><br><span class="line">libraryDependencies += <span class="string">"com.typesafe.akka"</span> %% <span class="string">"akka-actor"</span> % <span class="string">"2.3.8"</span></span><br></pre></td></tr></table></figure>
<p>혹은 여러 라이브러리를 한번에 명시할 경우 <code>Seq</code>를 사용해서</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">name :</span>= <span class="string">"SCells Spreadsheet"</span></span><br><span class="line"></span><br><span class="line"><span class="string">version :</span>= <span class="string">"0.1.0"</span></span><br><span class="line"></span><br><span class="line"><span class="string">scalaVersion :</span>= <span class="string">"2.11.4"</span></span><br><span class="line"></span><br><span class="line">libraryDependencies ++= Seq(</span><br><span class="line">    <span class="string">"org.scala-lang"</span> % <span class="string">"scala-swing"</span> % <span class="string">"2.11+"</span>,</span><br><span class="line">    <span class="string">"org.scala-lang.modules"</span> %% <span class="string">"scala-parser-combinators"</span> % <span class="string">"1.0.3"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>이런 식으로 프로젝트 루트에 build.sbt파일을 만들고, <code>sbt update</code>를 통해 가져온 뒤 <code>sbt eclipse</code>를 통해 이클립스에 import할 수 있는 프로젝트를 생성할 수 있다.</p>
<h3>akka</h3>
<p>책의 예제는 <code>scala.actors</code>가 기준이라 <code>akka.actor</code>로 예제 소스를 다시 쓰고 싶었지만 제대로 이해하지 못해서 도움이 될만한 글을 검색하던 도중 오현석님의 <a href="http://www.enshahar.me/2014/07/akka.html?view=classic" target="_blank" rel="external">프로그래밍 인 스칼라 액터 예제 akka로 변환하기(1) - 간단한 액터</a>를 발견해서 이 글과 <a href="http://docs.scala-lang.org/overviews/core/actors-migration-guide.html" title="The Scala Actors Migration Guide" target="_blank" rel="external">마이그레이션 가이드</a>를 읽고 시도해보려다가 잘 안돼서 다시 검색하던 도중 누군가 만들어준 <a href="https://github.com/drozzy/parallel-discrete-event-akka" target="_blank" rel="external">프로젝트</a>를 발견했다. 혹시 필요한 분들을 위해 남겨둔다.</p>
<hr>
<p>책을 읽으면서 간략하게 메모해놓은 것을 토대로 짧은 후기와 함께 같은 고생을 할 분들을 위해 약간의 도움을 남기고자했는데 의외로 글이 길어졌다. 스칼라를 배우면서 좋았던건 처음에 언급했던 것처럼 함수형이라는 패러다임에 대한 이해에 도움이 된다는 것이었다. 설계부터 변경할 수 없는 값(immutable)이나 지연평가 등 함수형을 잘 살릴 수 있는 구조로 만들수도 있지만, 평소에 하던 스타일에 크게 변형을 주지 않으면서도 세세한 부분의 조금 더 좋게 개선할 수 있는 직교적(orthogonal)인 개념이라는 점에서 누구에게나 도움이 될 수 있지 않을까 생각한다. 다른 패러다임들이 무엇이 있을지 궁금해하던 차에 이 책을 읽는 도중에 발견했던 글이 있는데, AI의 대부격이라는 피터 노빅의 &quot;프로그래밍 10년 완성&quot;이라는 글에서 눈에 들어온 문단을 인용해본다.</p>
<blockquote>
<p>프로그래밍을 정복하기 위한 나만의 비법이 있다:</p>
<ul>
<li>최소 다섯가지 프로그래밍 언어를 배워라. class abstractions (자바 또는 C++) 지원하는 언어, coroutines을 (Icon 또는 Scheme) 지원하는 언어, functional abstraction (Lisp 또는 ML) 지원하는 언어, syntactic abstraction (Lisp) 지원하는 언어, declarative specifications를 (Prolog또는 C++ 템플렛) 지원하는 언어, 그리고 parallelism을 (Sisal) 지원하는 언어를 한개씩 배워라.</li>
</ul>
<p><a href="http://www.norvig.com/21-days.html" title="Teach Yourself Programming in Ten Years" target="_blank" rel="external">프로그래밍 10년 완성</a>(<a href="http://blog.magicboy.net/entry/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-10%EB%85%84-%EC%99%84%EC%84%B1" target="_blank" rel="external">번역</a>)에서</p>
</blockquote>
<hr>
<h5>업데이트 01(2015-01-19 02:40)</h5>
<p><a href="https://groups.google.com/forum/#!forum/scala-korea" target="_blank" rel="external">라 스칼라 코딩단</a>의 <a href="https://lascala.slack.com/" target="_blank" rel="external">슬랙 채널</a>을 통해 오현석님의 조언을 받아, akka 부분과 REPL에서 scala-xml이 작동하는 이유에 대해 정정</p>
<!-- reference and style -->
<style type="text/css">
blockquote p:first-child { text-align: initial !important; }
blockquote p:last-child { text-align: right; }
</style>
]]></content:encoded>
      <comments>http://seoh.github.io/blog/2015/01/18/pis-review/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Framer에서 swipe/drag 제스쳐 프로토타이핑하기]]></title>
      <link>http://seoh.github.io/blog/2014/09/10/prototyping-swipe-and-drag-gestures-with-framer-3/</link>
      <guid>http://seoh.github.io/blog/2014/09/10/prototyping-swipe-and-drag-gestures-with-framer-3/</guid>
      <pubDate>Tue, 09 Sep 2014 15:00:00 GMT</pubDate>
      <description>
      <![CDATA[
Translation of &quot;Prototyping swipe and drag gestures with Framer 3&quot; into Korean, under the same license as the original.

우리는 Potluck에서 iOS앱에서 인터렉션을 테스트해보고 프로토타이핑을 하기 위해 Framer.js를 사용하기 시작했다]]>
      </description>
      <content:encoded><![CDATA[<blockquote>
<h3>Translation of &quot;<a href="https://medium.com/@gem_ray/prototyping-swipe-and-drag-gestures-with-framer-3-2e405d50b600" target="_blank" rel="external">Prototyping swipe and drag gestures with Framer 3</a>&quot; into Korean, under the same license as the original.</h3>
</blockquote>
<p>우리는 <a href="https://www.potluck.it/" target="_blank" rel="external">Potluck</a>에서 iOS앱에서 인터렉션을 테스트해보고 프로토타이핑을 하기 위해 Framer.js를 사용하기 시작했다. Framer는 모바일과 데스크탑 앱에서의 인터렉션 프로토타이핑과 에니메이션을 위한 자바스크립트 프레임워크다. 쿼츠 콤포저(Quartz Composer)보다 러닝커브가 훨씬 낮고 아이폰과 데스크탑 양쪽에서 쉽게 실행할 수 있는 훌륭한 대안이다. 키노트에서 시작해서 실제같은 인터렉티브 프로토타입을 단계별로 만들 수 있다.</p>
<p>자바스크립트 기반이기 때문에 특히 드래그나 스와이프같은 복잡한 제스쳐를 만들 때 좋다. 스와이프 거리에 따라 엘리먼트를 움직이거나 사라지게할 때 혹은 특정거리 이상 스와이프할 때 액션이 발생하도록 할 수 있다.</p>
<p>신생 프로젝트라 예제나 문서들이 너무 없다. 그래서 배웠던 것들을 공유하려고 생각했다.</p>
<hr>
<p>시작하기 전에 타이핑하기 귀찮은 사람을 위해 [CodePen](http://codepen.io/seoh/full/AqycD에 완성본을 올려놨다.</p>
<h1>Activate on release</h1>
<p>다른 액션을 가진 테이블 셀들로 간단한 예제를 시작해보자.</p>
<p>일단 보통 아이폰 스크린을 표시하기 위한 컨테이너 뷰를 만들어보자. 시스템 상태바를 가진 웹앱을 프로토타이핑하기 위해 높이는 598px로 정했다. (역주, 원문에서는 1096px였지만 웹에서 확인하기 좋게 절반으로 줄였다.)</p>
<p data-height="630" data-theme-id="0" data-slug-hash="teAkE" data-default-tab="js" data-user="seoh" class="codepen"></p>
<p>셀에서 사용자에게 보이는 부분을 정한 컨테이너를 만들고, 화면 밖에서 슬라이드하면 셀이 나타나도록 할 것이다.</p>
<p data-height="630" data-theme-id="0" data-slug-hash="hrvAG" data-default-tab="js" data-user="seoh" class="codepen"></p>
<p>이렇게 보일 것이다.</p>
<p><img src="/blog/images/prototyping-swipe-and-drag-gestures-with-framer-3/1.png" alt=""></p>
<p>이제 셀에 드래그를 추가해보자.</p>
<p data-height="630" data-theme-id="0" data-slug-hash="lqmjo" data-default-tab="js" data-user="seoh" class="codepen"></p>
<p>원하는 기능은 아니지만 어디로든 드래그할 수 있다.</p>
<p><img src="/blog/images/prototyping-swipe-and-drag-gestures-with-framer-3/2.gif" alt=""></p>
<hr>
<p>더 구체적인 제스쳐를 구현하기 위해 드래그 이벤트 핸들러를 사용할 수도 있다. 뭔가 드래그할 때 세가지 이벤트가 발생한다. <code>Events.DragStart</code>는 드래그를 시작할 때 한번, <code>Events.DragEnd</code>는 드래그를 놓았을 때 한번 발생한다. <code>Events.DragMove</code>는 마우스나 손가락을 움직일 때 계속 발생한다.</p>
<p>draggable은 &quot;speed&quot; 속성을 갖는데 마우스 움직임에 따라 어느 정도의 속도로 움직일지 결정한다. 속도를 <code>0</code>으로 설정하면 물체가 해당하는 방향(축)으로 이동하지 않게 된다.</p>
<p data-height="630" data-theme-id="0" data-slug-hash="DKtdp" data-default-tab="js" data-user="seoh" class="codepen"></p>
<p>드래그가 끝났을 때 무엇을 할지 정할 수도 있는데, 여기에서는 원래 물체를 자리로 돌아가게 해보자.</p>
<p data-height="630" data-theme-id="0" data-slug-hash="GHwLo" data-default-tab="js" data-user="seoh" class="codepen"></p>
<p><img src="/blog/images/prototyping-swipe-and-drag-gestures-with-framer-3/3.gif" alt=""></p>
<hr>
<p>이제 화면 밖의 엘리먼트가 드래그할 때 나타나도록 해보자. 그 엘리먼트는 셀 컨테이너의 차일드 뷰가 될 것이고(그래서 셀과 함께 움직일 것이고) 그냥 화면 밖에 놓도록 하겠다.</p>
<p data-height="630" data-theme-id="0" data-slug-hash="liKwL" data-default-tab="js" data-user="seoh" class="codepen"></p>
<p>이 액션 바를 추가한 다음에 셀을 왼쪽으로 끌면 화면 오른쪽 끝에서 나타나는걸 볼 수 있다.</p>
<p><img src="/blog/images/prototyping-swipe-and-drag-gestures-with-framer-3/4.gif" alt=""></p>
<p>좀 재미있는걸 넣어보자. 드래그 핸들러는 액션 바를 조금이라도 움직일 때마다 실행되는데, 얼마나 셀을 움직이는지에 따라 색깔을 바꾸게 만들 수 있다.</p>
<p>(얼마나 셀을 움직였는지에 대한)범위를 다른 (바의 색상)범위로 바꾸는 것은 <code>Utils.mapRange</code> 함수를 통해 쉽게 할 수 있다.</p>
<p>(역주: 원문은 원래 framerjs 2를 기준으로 작성되어 <a href="http://processing.org/" target="_blank" rel="external">Proccessing 프레임워크</a>의 <code>map_range</code>라는 함수를 사용했는데 중요한 정보는 아니다.)</p>
<p>이 함수에서는 <code>[low1, high1]</code> 범위에 있는 value를 <code>[low2, high2]</code> 범위에서의 같은 위치(비율)로 변환해준다. 이제 셀의 <em>x축 좌표</em>를 액션 바의 <em>투명도</em>로 바꿔보자.</p>
<p data-height="630" data-theme-id="0" data-slug-hash="DHBev" data-default-tab="js" data-user="seoh" class="codepen"></p>
<p>셀을 드래그할 때 액션 바의 색은 다음과 같이 변한다.</p>
<p><img src="/blog/images/prototyping-swipe-and-drag-gestures-with-framer-3/5.gif" alt=""></p>
<p>충분히 액션 바를 드래그했을 때는 그대로 열려있도록 만들고 싶다. 이걸 하려면, DragEnd 핸들러에서 얼마나 드래그되었는지 확인하고 특정 너비를 넘었다면 계속 열려있도록 해보자.</p>
<p data-height="630" data-theme-id="0" data-slug-hash="qCdrl" data-default-tab="js" data-user="seoh" class="codepen"></p>
<p><img src="/blog/images/prototyping-swipe-and-drag-gestures-with-framer-3/6.gif" alt=""></p>
<h1>Activate on threshold</h1>
<p>탭을 밀었을 때 계속 열려있도록 해봤다. 탭까지 가지 않고 액션을 할 수는 없을까? iOS 6의 당겨서 새로고침이 좋은 예다. 충분히 당기면 탭까지 가지 않아도 새로고침이 일어난다. (역주, 여기에서는 특정 길이만큼 드래그 후 이벤트 발생으로 애니메이션을 실행하는 것까지만 예제로 한다.)</p>
<p>위아래로 움직이는 두번째 셀을 만들어보자.</p>
<p data-height="630" data-theme-id="0" data-slug-hash="udyBe" data-default-tab="js" data-user="seoh" class="codepen"></p>
<p>셀을 100px 아래로 내리면 쪼그라들게 해보자. 일단 이렇게 시도해봤다.</p>
<p data-height="630" data-theme-id="0" data-slug-hash="ekgDo" data-default-tab="js" data-user="seoh" class="codepen"></p>
<p><img src="/blog/images/prototyping-swipe-and-drag-gestures-with-framer-3/7.gif" alt=""></p>
<p>애니메이션이 좀 산만하다. 드래그할 때마다 계속 DragMove 이벤트가 발생하고 계속 애니메이션을 시작하려고 한다. 그래서 조건이 만족될 때 딱 한번만 발생하도록 해보자.</p>
<p data-height="630" data-theme-id="0" data-slug-hash="trboC" data-default-tab="js" data-user="seoh" class="codepen"></p>
<p><img src="/blog/images/prototyping-swipe-and-drag-gestures-with-framer-3/8.gif" alt=""></p>
<p>(역주, 원문에서는 Drag와 Animate 기능이 충돌해서 제대로 Animate가 작동하지 않아 Drag하는 레이어와 Animate되는 레이어를 따로 뒀는데 버그가 수정되었는지 잘 작동해서 그 이하 부분은 생략했다.)</p>
<hr>
<h1>아이폰에서 테스트</h1>
<p>Framer Studio 1.7에서 Mirror라는 굉장히 편한 기능이 추가되었다. Studio에서 작업한 내용을 저장하고 Mirror 버튼을 누르면 작업중인 컴퓨터를 자동으로 서버로 사용해서 외부에서 접근할 수 있는 주소를 생성해준다. (역주, 원문에서는 Dropbox Public folder에 대한 내용이었지만 Mirror 기능이 더 유용하다고 생각해서 변경했다.)</p>
<script async src="http://codepen.io/assets/embed/ei.js"></script>]]></content:encoded>
      <comments>http://seoh.github.io/blog/2014/09/10/prototyping-swipe-and-drag-gestures-with-framer-3/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Coding Dojo #2 후기]]></title>
      <link>http://seoh.github.io/blog/2014/08/09/coding-dojo-2nd/</link>
      <guid>http://seoh.github.io/blog/2014/08/09/coding-dojo-2nd/</guid>
      <pubDate>Fri, 08 Aug 2014 15:00:00 GMT</pubDate>
      <description>
      <![CDATA[저번에 이은 Coding Dojo에 다녀왔다. 이번 범위는 함수에서 클로저까지.
1. 스코프 내의 변수 잡기

클로저는 사용자의 코드 안에서 전달되거나 사용할 수 있는 기능을 포함한 독립적인 블록(block)입니다. Swift에서의 클로저는 C 및 Objective-C 의 blocks와 유사하며, 다른 언어의 람다(lambda)와도 유사합니다. 클로저는 자]]>
      </description>
      <content:encoded><![CDATA[<p>저번에 이은 <a href="http://osxdev.org/forum/index.php?threads/8-6-swift-%EC%BD%94%EB%94%A9%EB%8F%84%EC%9E%A5-2%ED%9A%8C-%EA%B3%B5%EC%A7%80.373/" target="_blank" rel="external">Coding Dojo</a>에 다녀왔다. 이번 범위는 함수에서 클로저까지.</p>
<h1>1. 스코프 내의 변수 잡기</h1>
<blockquote>
<p>클로저는 사용자의 코드 안에서 전달되거나 사용할 수 있는 기능을 포함한 독립적인 블록(block)입니다. Swift에서의 클로저는 C 및 Objective-C 의 blocks와 유사하며, 다른 언어의 람다(lambda)와도 유사합니다. 클로저는 자신이 정의된 컨텍스트(context)로부터 임의의 상수 및 변수의 참조(reference)를 획득(capture)하고 저장할 수 있습니다.</p>
<p><a href="http://seoh.github.io/Swift-Korean/#09-closures-">09 클로저 (Closures) by inureyes</a></p>
</blockquote>
<p>for-loop(<code>for var...</code>)의 스코프에 있는 변수를 사용하는 함수를 만드는데, 해당하는 변수의 값이 스코프 내에서 계속 변하는 경우에 loop가 끝난 뒤 당연히 마지막값을 기준으로 함수가 실행되는 상황에서 현재값을 저장할 수 있는 방법에 대한 문제였다.</p>
<p>해결책은</p>
<ol>
<li>변수를 다시 캡처한다. <code>var _i = i</code></li>
<li>for-loop를 돌 때 <code>for var...</code>가 아니라 for-in으로 돌면 상수<code>let</code>가 되어 따로 캡처할 필요가 없다.</li>
<li>값을 받아서 그 값을 캡처하는 함수를 리턴하는 함수를 만든다.</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">capture</span><span class="params">(i:Int, closure:Int-&gt;Int)</span></span> -&gt; ()-&gt;<span class="type">Int</span> &#123;  </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">sth</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> closure(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sth</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// capture(i)&#123; $0*$0 &#125;</span></span><br></pre></td></tr></table></figure>
<p>3번의 경우를 더 간단하게 만들기 위해서 JavaScript의 즉시실행함수(IIFE)를 흉내내고 싶었는데, <a href="http://stackoverflow.com/questions/25163311/type-inference-of-iife-in-swift" target="_blank" rel="external">Swift의 버그</a> 때문에 현재 단순히 값만 리턴하는 IIFE도 <code>var</code>는 안되고 <code>let</code>을 써야 타입 추론이 가능하며, let을 쓰더라도 함수를 리턴하는 경우에도 에러가 나고, IIFE 속에서 조건문(conditional statement)이 존재할 경우 경우의 수에 대한 superset을 추론하는게 아니라 그냥 에러가 난다.</p>
<h1>2. 부분함수와 합성함수의 단계적 구현</h1>
<h3>2.1. 기본 구현</h3>
<p>Swift에서도 함수형 프로그래밍 스타일을 지원하도록 Array에 filter, map, reduce 등의 메소드들이 존재해서 array.filter{}.map{}.reduce(){} 같은 스타일로 작성할 수 있다. 그래서 특정 조건까지의 배열을 뽑아서(<code>take</code>) filter와 map을 체이닝해서 변이(tramsform)된 배열을 구하는 문제부터 시작했다. 앞/뒤에서 특정 길이만큼 읽는 함수는 Swift의 기본 라이브러리에서 <code>prefix와</code> <code>suffix</code>를 통해 지원하고 함수형 프로그래밍에서는 보통 <code>take</code>/<code>takeRight라는</code> 이름으로 지원된다. 특정 조건까지 읽는 함수는 <code>takeWhile</code>이라고 보통 부르는데, Swift에서 구현되어있지 않아서 도장에서는 <a href="https://github.com/pNre/ExSwift/#instance-methods" target="_blank" rel="external">ExSwift</a>에 있는 <code>takeWhile</code>의 소스가 제공되었다.</p>
<h3>2.2. Pythonic solution</h3>
<p>Python, underscore.js처럼 filter/map/reduce라는 함수에 sequence를 인자로 넘기는 식으로 개발을 하다보면 체이닝이 아니라 reduce(map(filter(... 처럼 전역함수를 이용해 구현할 수도 있는데, 이럴 경우에는 실행되는 순서와 함수호출의 순서가 역순이고, 값을 평가하는 함수를 인자로 넘길 때 인자로 받는 전역함수와의 거리가 멀어져서 가독성이 떨어지는 문제가 생긴다. 이 문제를 부분 함수(partial function)와 합성 함수(compose function)을 이용해서 인자를 받는 순서를 바꾸면 훨씬 가독성이 올라간다.</p>
<h3>2.3. Functional Programming</h3>
<p>함수형 프로그래밍으로 구현하기 위해서는 일단 1급 시민(first-class citizen, 혹은 1급 함수나 1급 객체 등으로 불린다)이라는 개념에 대해 이해가 먼저 필요하다. Java의 경험이 있다면 <a href="http://blog.doortts.com/135" target="_blank" rel="external">함수형 언어로 가는 길 (중편) - 일급객체</a>, JavaScript의 경험이 있다면 <a href="http://www.nextree.co.kr/p4150/" target="_blank" rel="external">Javascript : 함수(function) 다시 보기</a>라는 자세한 설명의 글들이 있고 영문으로는 더 자세하고 풍부한 자료들이 있다. 그리고 함수형 프로그래밍에 대한 패러다임의 이해도 필요한데, 가장 좋은 방법은 함수형 프로그래밍을 지원하는 언어를 배우는 것이다. Twitter에서 만든 Scala School이라는 Scala 입문 강의가 있는데 <a href="http://twitter.github.io/scala_school/ko" target="_blank" rel="external">한글 번역</a>도 존재한다. 혹은 Java 경험이 있다면 <a href="http://www.hanbit.co.kr/ebook/look.html?isbn=9788979149678" target="_blank" rel="external">자바 개발자를 위한 함수형 프로그래밍</a>라는 eBook을, JavaScript 경험이 있다면 <a href="http://www.hanbit.co.kr/book/look.html?isbn=978-89-6848-079-9" target="_blank" rel="external">함수형 자바스크립트</a>라는 좋은 책들도 있다.</p>
<h3>2.4. Solution</h3>
<p>다시 도장 이야기로 돌아가서, 이 문제를 해결하기 위해 영후님은 F#이라는 언어의 pipe-forwarding(<code>|&gt;</code>)이라는 연산자를 구현하셨다. <a href="http://undefinedvalue.com/2014/07/13/fs-pipe-forward-operator-swift" target="_blank" rel="external">Swift에서의 pipe-forwarding |&gt;의 구현</a>이라는 글을 읽어보면 구현체와 그 설명이 자세히 나와있다.</p>
<p>도장에서 나온 문제와 일치하지는 않지만 위에 나온 과정들을 종합해보면 이런 예제를 만들 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> |&gt;   &#123; <span class="keyword">precedence</span> <span class="number">50</span> <span class="keyword">associativity</span> <span class="keyword">left</span> &#125;</span><br><span class="line"></span><br><span class="line">public <span class="func"><span class="keyword">func</span> |&gt; <span class="generics">&lt;T,U&gt;</span><span class="params">(lhs: T, rhs: T -&gt; U)</span></span> -&gt; <span class="type">U</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> rhs(lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">ifilter</span><span class="generics">&lt;T&gt;</span><span class="params">(closure: T-&gt;Bool)</span></span> -&gt; [<span class="type">T</span>]-&gt;[<span class="type">T</span>] &#123;  </span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="built_in">filter</span>($<span class="number">0</span>, closure) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">imap</span><span class="generics">&lt;T,S&gt;</span><span class="params">(closure: T-&gt;S)</span></span> -&gt; [<span class="type">T</span>]-&gt;[<span class="type">S</span>] &#123;  </span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="built_in">map</span>($<span class="number">0</span>, closure) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  </span><br><span class="line">         |&gt; ifilter  &#123; $<span class="number">0</span>%<span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">         |&gt; imap     &#123; $<span class="number">0</span>*<span class="number">2</span> &#125;</span><br><span class="line">         |&gt; imap     &#123; <span class="type">String</span>($<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(list) <span class="comment">// ["4", "8"]</span></span><br></pre></td></tr></table></figure>
<h1>3. Accumulator</h1>
<p>누산기(accumulator)는 함수 하나를 리턴하는데, 그 함수는 인자를 하나 받을 때마다 그 값들이 누산된 결과를 리턴한다. 클로저에서 값을 캡처해서 리턴하는 것은 1번 문제에서 했고, 캡처된 값을 변경하도록 하는 것과 파라미터로 정의된 값을 다시 변수로 사용해서 소스코드를 짧게 만들도록 구현하는게 목적이었다.</p>
<h1>4. Jensen's Device</h1>
<p>이번에도 알고리즘 문제가 하나 나왔다. <a href="http://en.wikipedia.org/wiki/Jensen's_Device" target="_blank" rel="external">Jensen's Device</a>라는 문제로 한 변수를 캡처하고 있는 클로저를 계속 이용해서 따로 변수 선언없이 파라미터만으로 문제를 해결하도록하는 문제였다. 인자로 넘길 때 스코프 명시(<code>{}</code>)없이 쓸 수 있도록 해주는 <code>@auto_closure</code>라는 키워드에 대해 배웠다.</p>
<h1>5. Conclusion</h1>
<p>1회의 난이도가 1이었다면 이번 난이도는 10쯤 된다. 다음의 난이도는 얼마나 될지 모르겠다.</p>
<style type="text/css">
blockquote p:first-child { text-align: initial !important; }
blockquote p:last-child { text-align: right; }
</style>]]></content:encoded>
      <comments>http://seoh.github.io/blog/2014/08/09/coding-dojo-2nd/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Coding Dojo #1 후기]]></title>
      <link>http://seoh.github.io/blog/2014/07/24/coding-dojo-1st/</link>
      <guid>http://seoh.github.io/blog/2014/07/24/coding-dojo-1st/</guid>
      <pubDate>Wed, 23 Jul 2014 15:00:00 GMT</pubDate>
      <description>
      <![CDATA[OSXDev에서 열린 Coding Dojo에 다녀왔다. 보통 Dojo가 붙은 사이트들을 생각해서 이해하지 못하면 어쩌나 긴장했는데 다행히 난이도는 예상보다 낮았다. 타겟은 &quot;책을 읽었다&quot;와 &quot;이해했다&quot; 사이의 사람이 대상인 것 같다. 그러니까 책은 읽었는데 어떻게 써야할지 감이 안오는 사람들을 위한 '체득'의 시간 정도?]]>
      </description>
      <content:encoded><![CDATA[<p>OSXDev에서 열린 <a href="http://osxdev.org/forum/index.php?threads/swift-%EC%BD%94%EB%94%A9%EB%8F%84%EC%9E%A5-1%ED%9A%8C-%EA%B3%B5%EC%A7%80.367/" target="_blank" rel="external">Coding Dojo</a>에 다녀왔다. 보통 Dojo가 붙은 사이트들을 생각해서 이해하지 못하면 어쩌나 긴장했는데 다행히 난이도는 예상보다 낮았다. 타겟은 &quot;책을 읽었다&quot;와 &quot;이해했다&quot; 사이의 사람이 대상인 것 같다. 그러니까 책은 읽었는데 어떻게 써야할지 감이 안오는 사람들을 위한 '체득'의 시간 정도? 문제를 풀어보고 해석하고의 반복으로 진행되어 네 문제를 풀었다.</p>
<p>진행했던 문제들과 소스보다는 어떤 의도의 문제들이었고 어떤 것을 얻었나를 정리해본다.</p>
<hr>
<h1>1. if문에서의 Optional과 Boolean의 차이</h1>
<p>트위터에 예전에 올라왔던 문제인데 이 문제와 같은 의도였다.</p>
<blockquote class="twitter-tweet" lang="ko"><p>Swift 퀴즈 - 아래 코드의 실행 결과는 무엇일까요? <a href="http://t.co/5wK9hEnILn" target="_blank" rel="external">pic.twitter.com/5wK9hEnILn</a></p>&mdash; 김정현 (@gluebyte) <a href="https://twitter.com/gluebyte/statuses/487490260075417600" target="_blank" rel="external">2014년 7월 11일</a></blockquote>
<script async src="http://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>팁, 경우에 따라 다르겠지만 Boolean만 처리하지 말고 Optional에서 nil일 때도 처리해주는게 좋다.</p>
<h1>2. switch에서의 pattern matching</h1>
<p>복잡한 케이스에 대해서 switch-case를 단순히 objective-c에서 사용했던 것처럼 쓰거나 if-else문을 반복하는 것보다 tuple로 묶어서 한번에 처리하면 깔끔하고, where절(guard)을 통해 조건을 처리하면 더 깔끔하게 처리된다.</p>
<p>팁, pattern matching에서는 분기가 길어지면 case가 switch문과 거리가 멀어져서 어떤 의미인지 알기 어려운데, 특히 case에 true/false를 사용하는 경우 의미를 바로 알기 어려우므로 enum을 사용해서 의미있는 값을 변수로 만들어서 표현하면 좋다.</p>
<h1>3. 간단한 알고리즘 풀이</h1>
<p>중첩된 for문을 어떻게 사용하는지에 대한 문제. 참고로 100 doors 문제였다.</p>
<h1>4. repeatString</h1>
<p>String에 대한 기본 사용법(concat)과 loop 등을 사용한 정해진 횟수의 문자열 반복.</p>
<hr>
<p>진도가 Control Flow까지만여서 그 안에서만으로 해결할 수 있는 문제들을 짧은 시간 내에 제출하느라 고생하셨으리라 생각된다.</p>
<p>덧 1, 4번 문제의 경우 제약 때문에 함수로 구현했지만 operator overloading을 통해 쓰기 좋게 만들 수도 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">repeatString</span><span class="params">(<span class="built_in">count</span> n:Int,string s:String)</span></span> -&gt; <span class="type">String</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Array</span>(<span class="built_in">count</span>:n, repeatedValue:s).<span class="built_in">reduce</span>(<span class="string">""</span>,+)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">@infix</span> <span class="func"><span class="keyword">func</span> * <span class="params">(<span class="keyword">left</span>: String, <span class="keyword">right</span>: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> repeatString(<span class="built_in">count</span>: <span class="keyword">right</span>, string: <span class="keyword">left</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">@infix</span> <span class="func"><span class="keyword">func</span> * <span class="params">(<span class="keyword">left</span>: Int, <span class="keyword">right</span>: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> repeatString(<span class="built_in">count</span>: <span class="keyword">left</span>, string: <span class="keyword">right</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"a"</span> * <span class="number">2</span>) <span class="comment">// "aa"  </span></span><br><span class="line"><span class="built_in">println</span>(<span class="number">2</span> * <span class="string">"a"</span>) <span class="comment">// "aa"</span></span><br></pre></td></tr></table></figure>
<p>덧 2, swift 프로젝트에서 다른 파일에 구현을 해도 하나로 묶어서 해석하므로 같은 이름의 함수를 구현하면 에러가 난다는 질문이 있었는데, 얼마 전에 추가된 접근자(access control)을 통해 해결할 수 있을 줄 알고 시도해봤지만 안된다. c처럼 static 키워드가 생기거나 다른 방법을 찾아봐야겠다.</p>
]]></content:encoded>
      <comments>http://seoh.github.io/blog/2014/07/24/coding-dojo-1st/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[V8 Optimization killers]]></title>
      <link>http://seoh.github.io/blog/2014/06/28/v8-optimization-killers/</link>
      <guid>http://seoh.github.io/blog/2014/06/28/v8-optimization-killers/</guid>
      <pubDate>Fri, 27 Jun 2014 15:00:00 GMT</pubDate>
      <description>
      <![CDATA[
Translation of &quot;Optimization killers&quot; into Korean, under the same license as the original.

도입
이 문서는 예상보다 훨씬 성능이 떨어지는 코딩을 피하기 위한 조언이 포함되어 있다. 특히 V8(nodejs, Opera, Chromium 등)에서 최적화를 방해하는 패턴]]>
      </description>
      <content:encoded><![CDATA[<blockquote>
<h3>Translation of &quot;<a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers" target="_blank" rel="external">Optimization killers</a>&quot; into Korean, under the same license as the original.</h3>
</blockquote>
<h3>도입</h3>
<p>이 문서는 예상보다 훨씬 성능이 떨어지는 코딩을 피하기 위한 조언이 포함되어 있다. 특히 V8(nodejs, Opera, Chromium 등)에서 최적화를 방해하는 패턴에 대한 것이다.</p>
<h3>V8 배경지식 약간</h3>
<p>V8에서는 인터프리터가 없고 2가지 컴파일러가 있다, 일반 컴파일러(generic)와 최적화 컴파일러(optimizing).
즉, JavaScript 코드를 항상 컴파일하고 네이티브로 직접 실행한다는 뜻이다. 이는 빠르다는 뜻이다, 정말? 아니다. 네이티브로 컴파일된 코드라고 해서 성능적으로 큰 의미가 있는 것은 아니다. 단지 인터프리터 과부하를 제거한 것이라 최적화되지 않은 코드는 여전히 느리게 돌아간다.</p>
<p>예를 들어, 일반 컴파일러로 <code>a + b</code>는 다음과 같다.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, a  &#10;mov ebx, b  &#10;call RuntimeAdd</span><br></pre></td></tr></table></figure>
<p>위에서 보면 단지 런타임 함수를 호출한다. <code>a</code>와 <code>b</code>가 항상 정수라면 다음과 같이 된다.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, a  &#10;mov ebx, b  &#10;add eax, ebx</span><br></pre></td></tr></table></figure>
<p>런타임에서 복잡한 의미가 추가된 스크립트보다 훨씬 빠르게 작동할 것이다.</p>
<p>전자는 일 컴파일러에서 나오는 코드고, 후자는 최적화 컴파일러에서 나오는 코드다. 최적화 컴파일러로 컴파일된 코드는 대충 일반 컴파일러로 생성한 것보다 100배쯤 빠르다. 여기서 잠깐, 그냥 JavaScript로 코딩한다고 최적화된다는 것은 아니다. 많은 패턴들이 있는데, 최적화 컴파일러가 건들지 못하는 관용적인 것들이 있다.</p>
<p>중요한 점은, 이렇게 최적화 제외 코드는 그 함수를 포함하는 전체에 영향을 준다는 것이다. 코드는 한번에 한 함수만 최적화가 되고, 다른 코드가 무엇을 하든 전혀 모르고 있다(현재 최적화하고 있는 함수 내에 인라인된 코드가 아니라면).</p>
<p>이 가이드는 &quot;비최적화&quot;의 함수를 포함해 대부분의 패턴을 다룬다. 최적화 컴파일러가 더 많은 패턴을 인식할 수 있도록 업데이트 될 때 이런 우회 방법들은 불필요해질 것이다.</p>
<p>(본문은 요약)</p>
<h3>주제</h3>
<ol>
<li><a href="#1-_%ED%88%B4%EB%A7%81">툴링</a></li>
<li><a href="#2-_%EB%AF%B8%EC%A7%80%EC%9B%90_%EB%AC%B8%EB%B2%95">미지원 문법</a></li>
<li><a href="#3-_arguments_%EA%B4%80%EB%A6%AC"><code>arguments</code> 관리</a></li>
<li><a href="#4-_switch-case">switch-case</a></li>
<li><a href="#5-_for-in">for-in</a></li>
</ol>
<h3>1. 툴링</h3>
<p>최적화에 영향을 주는지 알아보기 위해 V8의 내부에서 사용하는 플래그를 사용할 수 있다.</p>
<p>HackerNews의 댓글을 보면 플래그 등에 대한 <a href="https://news.ycombinator.com/item?id=7943303" target="_blank" rel="external">추가 설명</a>이 있고, DailyJS.com에서 <a href="http://dailyjs.com/2014/06/26/optimization-killers/" target="_blank" rel="external">요약</a>되어있다.</p>
<h3>2. 미지원 문법</h3>
<p>현재까진 최적화되지 않는 문법</p>
<ul>
<li>제너레이터 함수</li>
<li>for-of를 포함하는 함수</li>
<li>try-catch를 포함하는 함수</li>
<li>try-finally를 포함하는 함수</li>
<li><code>let</code>이나 <code>const</code> 선언을 포함하는 함수</li>
<li><code>__proto__</code>나 <code>get</code>이나 <code>set</code> 선언이 있는 객체 표현식을 포함하는 함수</li>
</ul>
<p>앞으로도 계속 안될 것 같은 문법</p>
<ul>
<li><code>debugger</code>문을 포함하는 함수</li>
<li><code>eval()</code>을 호출하는 함수</li>
<li><code>with</code> 문을 포함하는 함수</li>
</ul>
<p><code>try-catch-finally</code>에 대해서는 다음과 같이 함수로 뽑아서 우회 가능</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorObject = &#123;value: <span class="literal">null</span>&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryCatch</span>(<span class="params">fn, ctx, args</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(ctx, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        errorObject.value = e;</span><br><span class="line">        <span class="keyword">return</span> errorObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = tryCatch(mightThrow, <span class="keyword">void</span> <span class="number">0</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);  </span><br><span class="line"><span class="comment">//Unambiguously tells whether the call threw</span></span><br><span class="line"><span class="keyword">if</span>(result === errorObject) &#123;  </span><br><span class="line">    <span class="keyword">var</span> error = errorObject.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">//result is the returned value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3>3. <code>arguments</code> 관리</h3>
<h4>3.1. <code>arguments</code>를 함수 내에서 사용하면서 파라미터로 넘겨준 변수에 다른 값을 넣을 때</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultArgsReassign</span>(<span class="params">a, b</span>) </span>&#123;  </span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">2</span>) b = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>우회</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reAssignParam</span>(<span class="params">a, b_</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> b = b_;</span><br><span class="line">    <span class="comment">//unlike b_, b can safely be reassigned</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">2</span>) b = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>혹은</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reAssignParam</span>(<span class="params">a, b</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (b === <span class="keyword">void</span> <span class="number">0</span>) b = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4>3.2. <code>arguments</code>를 외부로 노출</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leaksArguments1</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leaksArguments2</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leaksArguments3</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>우회</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doesntLeakArguments</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; ++i) &#123;</span><br><span class="line">        args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>혹은 빌드 과정에서 매크로를 사용해 치환하는 방법</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doesntLeakArguments</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    INLINE_SLICE(args, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bluebird에서 사용하는 방법</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doesntLeakArguments</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> $_len = <span class="built_in">arguments</span>.length;<span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>($_len); <span class="keyword">for</span>(<span class="keyword">var</span> $_i = <span class="number">0</span>; $_i &lt; $_len; ++$_i) &#123;args[$_i] = <span class="built_in">arguments</span>[$_i];&#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4>3.3. arguments에 값을 넣을 때</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignToArguments</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">arguments</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이것만 사용</p>
<ul>
<li><code>arguments.length</code></li>
<li>유효한 인덱스 <code>i</code>를 통해 <code>arguments[i]</code></li>
<li><code>.length</code>없이 직접 사용하지마라. <code>x.apply(y, arguments)</code> 이건 괜찮다. <code>.slice</code>와 <code>Function#apply</code>는 특별하니까</li>
</ul>
<h3>4. switch-case</h3>
<p>case 조건이 128개까지는 괜찮고 초과하면 최적화를 못한다.</p>
<h3>5. for-in</h3>
<h4>5.1. key가 지역변수가 아닐 때</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonLocalKey1</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>혹은</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonLocalKey2</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(key <span class="keyword">in</span> obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>외부로 노출하거나 해당 루프의 지역변수가 아니면 불가능.</p>
<h4>5.2. 순환하려는 객체가 &quot;simple enumerable&quot;이 아닐 때</h4>
<h5>5.2.1. &quot;hash table mode&quot;의 객체</h5>
<p>생성자 밖에서 동적으로 프로퍼티들을 추가하거나 삭제할 때 hash table mode가 된다.</p>
<h5>5.2.2. 프로토타입 체인에서 enumerable 프로퍼티를 가질 때</h5>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>이렇게 하면 모든 객체에서 for-in이 최적화되지 못한다. <code>Object.create(null)</code>만 예외. 필요하면 <code>Object.defineProperty</code>로 enumerable하지 않은 프로퍼티를 만들 수 있지만 비추. (역주, 이유는 나와있지 않음)</p>
<h5>5.2.3. 배열의 인덱스를 키값으로 사용할 때</h5>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteratesOverArray</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>배열을 순환하고 싶으면 <code>Object.keys</code>를 사용하는게 좋고, 프로토타입 체인 전체를 돌고 싶다면 다음과 같이 key값을 따로 모아서 처리한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritedKeys</span>(<span class="params">obj</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> ret = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        ret.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      <comments>http://seoh.github.io/blog/2014/06/28/v8-optimization-killers/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Sublime Text에서 swift파일 빌드하기]]></title>
      <link>http://seoh.github.io/blog/2014/06/25/build-swift-file-on-sublime-text/</link>
      <guid>http://seoh.github.io/blog/2014/06/25/build-swift-file-on-sublime-text/</guid>
      <pubDate>Tue, 24 Jun 2014 15:00:00 GMT</pubDate>
      <description>
      <![CDATA[조건

Sublime Text와 Package Control이 설치되어 있을 것
Swift 개발 환경이 설정되어있을 것

순서

Package Control을 통해 Swift 패키지 설치
Tools &gt; Build System &gt; New Build System... 에서 다음과 같이 입력한다.

1234&#123;    "cmd": ["swift"]]>
      </description>
      <content:encoded><![CDATA[<h4>조건</h4>
<ul>
<li>Sublime Text와 <a href="https://sublime.wbond.net/installation" target="_blank" rel="external">Package Control</a>이 설치되어 있을 것</li>
<li>Swift 개발 환경이 설정되어있을 것</li>
</ul>
<h4>순서</h4>
<ul>
<li>Package Control을 통해 Swift 패키지 설치</li>
<li>Tools &gt; Build System &gt; New Build System... 에서 다음과 같이 입력한다.</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">cmd</span>": <span class="value">[<span class="string">"swift"</span>, <span class="string">"-i"</span>, <span class="string">"$file"</span>]</span>,</span><br><span class="line">    "<span class="attribute">selector</span>": <span class="value"><span class="string">"source.swift"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>빌드 정보를 저장한다. (예, <code>Swift.sublime-build</code>)</li>
<li>cmd + B로 빌드한다.</li>
</ul>
<p><img src="/blog/images/build-swift-file-on-sublime-text/swift-sublime-build.png" alt=""></p>
<h4>부연 설명</h4>
<p>Swift 패키지를 설치하면 문법 강조는 기본으로 지원하고 각종 Snippet을 지원해서 Xcode만큼은 아니더라도 편하게 작성할 수 있다.</p>
<p><img src="/blog/images/build-swift-file-on-sublime-text/swift-sublime-snippet.png" alt=""></p>
<p><a href="https://github.com/quiqueg/Swift-Sublime-Package" target="_blank" rel="external">Swift 패키지 프로젝트</a>에서 패키지 파일들을 확인하면 보다 자세한 정보를 알 수 있다.</p>
]]></content:encoded>
      <comments>http://seoh.github.io/blog/2014/06/25/build-swift-file-on-sublime-text/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[쉘에서 현재 위치의 repository 정보 추가하기]]></title>
      <link>http://seoh.github.io/blog/2014/06/23/add-current-repository-info-to-shell/</link>
      <guid>http://seoh.github.io/blog/2014/06/23/add-current-repository-info-to-shell/</guid>
      <pubDate>Sun, 22 Jun 2014 15:00:00 GMT</pubDate>
      <description>
      <![CDATA[GitHub에서 공개한 Bash/Zsh/Tcsh용 Prompt

GitHub: git / contrib / completion /
기본 구조: (&lt;브랜치 이름&gt;)
설명: Put Your Git Branch in Your Bash Prompt

한줄 추가로 현재 브랜치 표시
기본 구조: (&lt;브랜치 이름&gt;)
설명: 명령 프롬프트에 현재 G]]>
      </description>
      <content:encoded><![CDATA[<h1>GitHub에서 공개한 Bash/Zsh/Tcsh용 Prompt</h1>
<ul>
<li>GitHub: <a href="https://github.com/git/git/blob/master/contrib/completion/" target="_blank" rel="external">git / contrib / completion /</a></li>
<li>기본 구조: (&lt;브랜치 이름&gt;)</li>
<li>설명: <a href="http://code-worrier.com/blog/git-branch-in-bash-prompt/" target="_blank" rel="external">Put Your Git Branch in Your Bash Prompt</a></li>
</ul>
<h3>한줄 추가로 현재 브랜치 표시</h3>
<p>기본 구조: (&lt;브랜치 이름&gt;)
설명: <a href="http://ccoroom.tumblr.com/post/14261727932/git" target="_blank" rel="external">명령 프롬프트에 현재 Git 브랜치 표시하기</a></p>
<h3>현재 브랜치와 컬러 표시</h3>
<p>기본 구조: (&lt;브랜치 이름&gt;)
설명: <a href="http://blog.outsider.ne.kr/616" target="_blank" rel="external">bash 프롬프트에 Git와 Mercurial의 branch를 표시하기</a>
비고: Mercurial도 가능.</p>
<h3>vcprompt를 이용한 프롬프트</h3>
<p>설명: <a href="http://blog.outsider.ne.kr/737" target="_blank" rel="external">vcprompt를 이용해서 bash 프롬프트에 VCS 정보 표시하기</a>
기본 구조: (&lt;형상관리 이름&gt;:&lt;브랜치 이름&gt; )
비고: VCS 이름, commit hash, branch, revision, modified file, not-added 등 각종 변수 지원</p>
<h3>Bash prompot에서 Git 정보 보기</h3>
<p>GitHub: <a href="https://github.com/magicmonty/bash-git-prompt" target="_blank" rel="external">magicmonty/bash-git-prompt</a>
기본 구조: (&lt;브랜치 이름&gt; &lt;브랜치 상태&gt;|&lt;로컬 상태&gt;)
설명: <a href="http://resoneit.blogspot.kr/2014/01/bash-git.html" target="_blank" rel="external">리눅스 bash shell에서 git 상태 정보 보기</a>
비고: add, conflict, modified, non-added, stashed, yet-pushed, yet-pulled 상태의 숫자 등 표시
결론
vcprompt를 이용했다. 이유는 homebrew로 설치 가능한 유일한 방법이라 설치하기가 쉬워서. 이전의 설정은 다음과 같다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PS1=<span class="string">"<span class="variable">$C_LIGHTGRAY</span>(\t)<span class="variable">$C_RESET</span> \W \u <span class="variable">$C_GRAY</span>$ <span class="variable">$C_RESET</span>"</span></span><br></pre></td></tr></table></figure>
<p>즉, ((시간) 사용자 현재디렉토리 $ )의 구조였다. 여기에서 vcprompt를 추가해서</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VC=<span class="string">" \$(vcprompt -f "</span><span class="variable">$C_BG_GREEN</span>%n:%b<span class="variable">$C_BG_RED</span>%m%u<span class="variable">$C_RESET</span><span class="string">")"</span>  </span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">"<span class="variable">$C_LIGHTGRAY</span>(\t)<span class="variable">$C_RESET</span> \W \u<span class="variable">$VC</span> <span class="variable">$C_GRAY</span>$ <span class="variable">$C_RESET</span>"</span></span><br></pre></td></tr></table></figure>
<p>((시간) 사용자 현재디렉토리 형상관리정보 $)의 구조로 변경했다.</p>
<p><img src="/blog/images/add-current-repository-info-to-shell/shell.png" alt="">
위와 같이 전/후가 변경되었다.</p>
<p>사용된 색상관련 변수는 <a href="http://blog.saltfactory.net/99" target="_blank" rel="external">터미널에서 프롬프트(Prompt)에 나타나는 정보와 색상 변경하기</a>를 참고하면 된다.</p>
]]></content:encoded>
      <comments>http://seoh.github.io/blog/2014/06/23/add-current-repository-info-to-shell/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Coursera - FPPiS 후기, 그리고 테스트]]></title>
      <link>http://seoh.github.io/blog/2012/11/17/after-coursera-fppis-and-test/</link>
      <guid>http://seoh.github.io/blog/2012/11/17/after-coursera-fppis-and-test/</guid>
      <pubDate>Sat, 17 Nov 2012 11:50:00 GMT</pubDate>
      <description>
      <![CDATA[coursera.org의 functional programming principle in scala의 진행이 끝났다. functional programming이라는 생소한 개념을 배우면서 재미있기도 했고, 강의를 시작하기 직전에 봤던 '자바 개발자를 위한 함수형 프로그래밍'를 읽으면서 제대로 알지 못했던 개념을 좀 더 확실하게 배웠다. 물론 강의와 서적 모]]>
      </description>
      <content:encoded><![CDATA[<p>coursera.org의 functional programming principle in scala의 진행이 끝났다. functional programming이라는 생소한 개념을 배우면서 재미있기도 했고, 강의를 시작하기 직전에 봤던 '자바 개발자를 위한 함수형 프로그래밍'를 읽으면서 제대로 알지 못했던 개념을 좀 더 확실하게 배웠다. 물론 강의와 서적 모두 '입문'에 대한 것이라 의미에 대해 알려면 더 많은 경험이 필요하겠고, 서적과 강의가 지향하는 바가 조금 달라서 내용도 다르지만 서적을 보면서 제대로 이해하지 못했던 개념을 강의를 보면서 이해하는데 도움이 되었고 기초가 있는 상태에서 다시 서적을 읽으면 더 이해가 잘 될 것 같다.</p>
<p>사실 강의를 읽으면서 도움이 된 것은 functional programming에 대한 이해보다 다른 것이다. 물론 functional programming에 대한 기초를 쌓는데도 무척 도움이 되었지만, 그것보다 과제를 진행하는데 있어서 '테스트'의 중요성에 대한 인식이 생겼다.</p>
<p>과제를 진행하는 방식은 이렇다.</p>
<ol>
<li>테스트 케이스가 주어진다.</li>
<li>작성해야하는 로직이 제외된 코드가 주어진다.</li>
<li>단계별로 로직을 구현하면서 테스트를 통해 작성된 로직이 유효한지 확인한다.</li>
<li>이전 단계에서 구현한 것을 기반으로 다음 단계의 로직을 작성한다.</li>
</ol>
<p>물론 주어진 테스트 케이스들 중에서 좋은 테스트 케이스만 있는 것이 아니다. 스펙에서 요구되었지만 테스트에서 확인하지 않은 케이스(정렬된 배열을 가져와야하는데 그 종류와 갯수만 확인하는 경우)는 다음 단계의 테스트를 통과하지 못한다. 그럴 경우에는 테스트에 성공한 코드로 돌아가서 수정을 해야하므로 좋은 테스트라고 볼 수 없다. 이런 식으로 좋은 테스트가 적성되어있는 경우에는 그 테스트를 통과하면 다시 그 코드를 수정할 필요가 없고, 성능상의 문제가 있는 경우에는 그 코드를 수정하고 다시 테스트를 통과하면 다른 코드들을 건들이지 않아도 된다.</p>
<p>여기에 대한 전제가 중요하긴 하다. 앞서 이야기했듯이 '좋은(명확한) 테스트가 작성되어 있을 것', 그리고 '확실히 단계별로 구분된 설계가 있을 것'이다. 이 전제들이 참 어렵지만, 반대로 생각하면 이 전제들이 확실한 경우가 있다. 바로 내가 겪었던 것과 같이 '과제'를 작성하는 경우다. 커다란 과제가 주어졌을 경우에 어디서부터 어떻게 접근해야할지 명세서를 봐도 막막한 경우가 있는데 그런 경우에 bottom-up으로 제대로 된 설계에 따라 테스트를 하나씩 거치면서 확실히 눈에 보이는 진척을 확인할 수 있다. 물론 실무에 적용하려면 저 전제들을 만족하기 참 힘들겠지만 말이다. 혹은 퍼포먼스의 이슈가 없거나 종속성이 적은 코드들의 경우에 신입사원들에게 연습시키는 용도로는 확실할 수 있다.</p>
<p>예전에 일하던 회사에서 '시켜서' 억지로 작성한 테스트들이 떠오르며 (사실 잘 떠오르지도 않지만) 부끄러워졌다. 사실 TDD라고 하지만 아직도 TDD가 뭔지 잘 모르겠고, 이해하지 못한 상태에서 작성한 테스트들은 당연히 좋은 테스트일리가 없었다. 이렇게 실무에서 어떻게 테스트를 더 잘 적용시킬 수 있는지에 대해 듣고 싶어서 저번달에 모 컨퍼런스에 다녀왔는데 그냥 '테스트는 의지를 가지고 해야 한다.'라는 말만 반복해서 하더라. 하긴 누군가가 말해줘도 그걸 체득하기는 어렵다. 계기와 경험이 중요한데 나는 일단 이 강의라는 계기를 얻었으니 앞으로 경험을 쌓도록 노력해야지.</p>
<p>참고로 80점 만점에서 60%(48점)만 얻으면 인증을 얻는데 과제를 너무 늦게 시작하는 바람에 1주차에 80% 감점을 받고 시작한 것을 합쳐서 69점으로 통과했다. 만점을 목표로 한 것에 비하면 부끄럽지만 인증을 받은 것만으로도 일단은 만족. 그리고 스칼라 스터디에 한번 참여해보고 싶었는데 영어 실력이 부족하여 참여할만큼 이해한 강의가 없어서 한번도 참여를 못한 것 두가지가 아쉽다.</p>
]]></content:encoded>
      <comments>http://seoh.github.io/blog/2012/11/17/after-coursera-fppis-and-test/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[underscore.js로 편해지자]]></title>
      <link>http://seoh.github.io/blog/2012/10/09/getting-cozy-with-underscore-js/</link>
      <guid>http://seoh.github.io/blog/2012/10/09/getting-cozy-with-underscore-js/</guid>
      <pubDate>Tue, 09 Oct 2012 01:21:00 GMT</pubDate>
      <description>
      <![CDATA[
Translation of &quot;Getting Cozy With Underscore.js&quot; into Korean, under the same license as the original.

들어가기 전에, functional javascript 자바스크립트의 함수형 프로그래밍에 대한 간략한 소개가 있는 슬라이드. 함수형 프로그래밍에 개념과 u]]>
      </description>
      <content:encoded><![CDATA[<blockquote>
<h2>Translation of &quot;<a href="http://code.tutsplus.com/tutorials/getting-cozy-with-underscore-js--net-24581" target="_blank" rel="external">Getting Cozy With Underscore.js</a>&quot; into Korean, under the same license as the original.</h2>
</blockquote>
<p>들어가기 전에, <a href="http://almostobsolete.net/talks/functionaljs/" target="_blank" rel="external">functional javascript</a> 자바스크립트의 함수형 프로그래밍에 대한 간략한 소개가 있는 슬라이드. 함수형 프로그래밍에 개념과 underscore의 컨셉을 이해하는데 도움이 된다.</p>
<hr>
<h1>Underscore.js와 만나다</h1>
<p>그래서 Underscore가 정확히 뭐하는건데?</p>
<blockquote>
<p>Underscore는 Prototype.js(혹은 Ruby)처럼 기본 JavaScript 객체들을 확장하지 않고 함수형 프로그래밍을 지원할 수 있는 유용한 JavaScript Library이다.</p>
</blockquote>
<p>Python이나 Ruby로 작업할 때 더 좋은 점은 훨씬 쉽게 쓸 수 있는 <code>map</code>같은 멋진 기본함수들이 있다는 것이다. 슬프게도 JavaScript의 현재 버전에서는 그런 native로 제공되는 것들이 꽤나 부실하다. 위에서 읽은 것처럼, Underscore.js는 단지 4kb라는 터무니없는 용량의 좀 멋진 JavaScript Library다.</p>
<hr>
<h2>Underscore in Action</h2>
<p>&quot;라이브러리 이야기는 충분히 많이 들었다&quot;, 라는 말할지도 모른다. 맞다, 하지만 일단 한번 보자. 임의의 시험점수 배열에서 90점 넘는 리스트가 필요하면 보통은 이렇게 짤 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scores = [<span class="number">84</span>, <span class="number">99</span>, <span class="number">91</span>, <span class="number">65</span>, <span class="number">87</span>, <span class="number">55</span>, <span class="number">72</span>, <span class="number">68</span>, <span class="number">95</span>, <span class="number">42</span>],</span><br><span class="line">topScorers = [], scoreLimit = <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=scores.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (scores[i]&gt;scoreLimit)</span><br><span class="line">   &#123;</span><br><span class="line">      topScorers.push(scores[i]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(topScorers);</span><br></pre></td></tr></table></figure>
<p>꽤 깔끔하고 심지어 최적화도 있는데, 내가 하려는 것보다는 좀 길다. underscore로 하면 이렇게 된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scores = [<span class="number">84</span>, <span class="number">99</span>, <span class="number">91</span>, <span class="number">65</span>, <span class="number">87</span>, <span class="number">55</span>, <span class="number">72</span>, <span class="number">68</span>, <span class="number">95</span>, <span class="number">42</span>],</span><br><span class="line">topScorers = [], scoreLimit = <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">topScorers = _.select(scores, <span class="function"><span class="keyword">function</span>(<span class="params">score</span>)</span>&#123; <span class="keyword">return</span> score &gt; scoreLimit;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(topScorers);</span><br></pre></td></tr></table></figure>
<p>넌 어떤지 모르겠지만 난 좀 너드같다. 저기있는 코드 굉장히 간결하고 읽기 좋다.</p>
<h2>괜찮긴한데 진짜 필요해?</h2>
<p>모든건 뭘 하려고 하는지에 달렸다. 단지 DOM 다루는데 사용을 제한한다면 jQuery로 원하는건 대부분 할 수 있다. 반대로, DOM이랑 관련없거나 좀 복잡한 MVC나 front-end 코드들이라면 underscore는 확실히 괜찮다. ECMA 스펙에 맞춰서 천천히 라이브러리들의 기능이 업데이트되는 동안에, 모든 브라우져에서 돌아가는건 가능하지도 않고 여러 브라우저들에서 돌아가게 하는 것도 또다른 악몽이다. underscore는 어디서든 작동하도록 좋은 추상화를 제공한다. 그리고 퍼포먼스를 중시하는 사람이거나 그래야하는 사람이면 underscore는 가능한 native 뒤에 구현된거라 가능한 최적화된 성능을 보장한다.</p>
<h2>시작해보자</h2>
<blockquote>
<p><a href="http://underscorejs.org/docs/underscore.html" target="_blank" rel="external">여기</a>서 소스를 가져다 넣기만 하면 페이지는 잘 돌아간다.</p>
</blockquote>
<p>적용시키는데 뭔가 큰 작업을 기대했으면 꽤나 실망할꺼다. 그냥 <a href="http://underscorejs.org/docs/underscore.html" target="_blank" rel="external">여기</a>에서 소스를 가져다 넣기만 하면 페이지는 잘 돌아간다. underscore는 global 영역에서 단일 객체로 만들어지고 모든 기능을 한다. 이 객체는 underscore 문자, _로 불린다. 흥미롭게도 jQuery가 dollar 문자($)로 돌아가는 것과 매우 비슷해 보인다. 또 jQuery처럼 충돌을 피하려면 다른 문자로 쓸 수도 있다.</p>
<h2>함수형? 아니면 객체지향?</h2>
<p>라이브러리의 공식적인 광고에는 함수형 프로그래밍 지원이라고 써있는데, 실제로 쓰는 다른 방법도 있다. 저 위에서 썼던 예제를 가져와보면</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scores = [<span class="number">84</span>, <span class="number">99</span>, <span class="number">91</span>, <span class="number">65</span>, <span class="number">87</span>, <span class="number">55</span>, <span class="number">72</span>, <span class="number">68</span>, <span class="number">95</span>, <span class="number">42</span>], topScorers = [], scoreLimit = <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">topScorers = _.select(scores, <span class="function"><span class="keyword">function</span>(<span class="params">score</span>)</span>&#123; <span class="keyword">return</span> score &gt; scoreLimit;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(topScorers);</span><br></pre></td></tr></table></figure>
<p>위의 방법은 함수형이나 절차지향적인 접근이다. 또 더 직관적이며 아마 더 확실하게 객체지향적으로 사용할 수도 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scores = [<span class="number">84</span>, <span class="number">99</span>, <span class="number">91</span>, <span class="number">65</span>, <span class="number">87</span>, <span class="number">55</span>, <span class="number">72</span>, <span class="number">68</span>, <span class="number">95</span>, <span class="number">42</span>], topScorers = [], scoreLimit = <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">topScorers = _(scores).select(<span class="function"><span class="keyword">function</span>(<span class="params">score</span>)</span>&#123; <span class="keyword">return</span> score &gt; scoreLimit;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(topScorers);</span><br></pre></td></tr></table></figure>
<p>실제로 '정답'이라는건 없지만, jQuery식으로 method 뒤에 chainging을 할 수 있다는 것을 알아두라.</p>
<h2>기능을 확인해보자</h2>
<p>underscore는 기능 자체의 숫자보다 많은 60개보다 조금 넘는 함수를 지원한다. 돌아가는 함수들을 그룹으로 다음과 같이 분류할 수 있다.</p>
<ul>
<li>Collections</li>
<li>Arrays</li>
<li>Objects</li>
<li>Functions</li>
<li>Utilities</li>
</ul>
<p>각각 뭘 하는지를 보고, 가능하면 섹션에서 한두개쯤 적용해보겠다.</p>
<h2>Collections</h2>
<p>connection은 배열이나 객체가 될 수 있고, 의미상으로 말하자면 자바스크립트에서의 (객체와 배열이)혼합된 배열이다. underscore는 collections에서 돌아가는 많은 method들을 제공한다. 위에서 이미 <code>select</code>를 봤다. 여기 더 쓸만한게 하나 있다.</p>
<h3>Pluck</h3>
<p>key와 value 쌍으로 이루어진 깔끔하고 짧은 배열이 있는데 여기에서 특정 속성을 추출하려고 한다. underscore로는 아주 쉽다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Tuts = [&#123;name : <span class="string">'NetTuts'</span>, niche : <span class="string">'Web Development'</span>&#125;, &#123;name : <span class="string">'WPTuts'</span>, niche : <span class="string">'WordPress'</span>&#125;, &#123;name : <span class="string">'PSDTuts'</span>, niche : <span class="string">'PhotoShop'</span>&#125;, &#123;name : <span class="string">'AeTuts'</span>, niche : <span class="string">'After Effects'</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> niches = _.pluck(Tuts, <span class="string">'niche'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(niches);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["Web Development", "WordPress", "PhotoShop", "After Effects"]</span></span><br></pre></td></tr></table></figure>
<p><code>pluck</code>을 쓰면 객체나 배열을 훑는 것만큼 속성을 뽑아내는 것은 간단하다. 각 사이트들이 분야(niche)에 속하는지 추출해봤다.</p>
<h3>Map</h3>
<p>map은 collection으로부터 함수를 통해 각 요소들을 바뀐 배열을 만든다. 앞에서 있던 예제에서 조금 더해봤다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Tuts = [&#123;name : <span class="string">'NetTuts'</span>, niche : <span class="string">'Web Development'</span>&#125;, &#123;name : <span class="string">'WPTuts'</span>, niche : <span class="string">'WordPress'</span>&#125;, &#123;name : <span class="string">'PSDTuts'</span>, niche : <span class="string">'PhotoShop'</span>&#125;, &#123;name : <span class="string">'AeTuts'</span>, niche : <span class="string">'After Effects'</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names = _(Tuts).pluck(<span class="string">'name'</span>).map(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>)</span>&#123;<span class="keyword">return</span> value + <span class="string">'+'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(names);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["NetTuts+", "WPTuts+", "PSDTuts+", "AeTuts+"]</span></span><br></pre></td></tr></table></figure>
<p>이름 끝에 +를 붙이도록 해서, 추출된 배열에는 +가 추가되어있다. 간단한 연쇄(method chaining; 여기에서는 pluck+map)를 하는데 제한은 없다. 지나가는 값들을 원하는데로 다 바꿀 수 있다.</p>
<h3>All</h3>
<p><code>all</code>은 collection 속의 모든 값들이 어떤 기준에 만족하는지 확인하는데 매우 유용하다. 예를 들어, 학생이 모든 과목에서 통과했는지 확인해보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Scores = [<span class="number">95</span>, <span class="number">82</span>, <span class="number">98</span>, <span class="number">78</span>, <span class="number">65</span>];</span><br><span class="line"><span class="keyword">var</span> hasPassed = _(Scores).all(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>)</span>&#123;<span class="keyword">return</span> value&gt;<span class="number">50</span>; &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(hasPassed);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2>Arrays</h2>
<p>underscore에만 있는 배열을 다루는 함수들이 굉장히 평이 좋은데, 다른 언어에 비해 JavaScript는 배열을 다루는 함수가 거의 없어서다.</p>
<h3>Uniq</h3>
<p>이 method는 기본적으로 배열을 읽어서 중복값을 제거하고 유일한 값들만 돌려준다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniqTest = _.uniq([<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(uniqTest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, 5, 4, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>거대한 데이터들을 추려서 중복값을 제거하는데 무척 편하다. 원래 배열의 순서를 유지하기 때문에 중복값 중 첫번째 값이 나온다는걸 명심하자.</p>
<h3>Range</h3>
<p>어떤 '범위'나 숫자들의 리스트를 만들 때 무척 편하다. 빠르게 예제를 보자</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tens = _.range(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tens);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]</span></span><br></pre></td></tr></table></figure>
<p>파라미터는 순서대로 시작하는 값, 끝나는 값, 그리고 차이값(step)다. 감소하는 범위를 만들고 싶으면 음수의 차이값을 쓰면 된다.</p>
<h3>Intersection</h3>
<p>이 method는 각 배열들을 두 배열씩 비교해서 같은 모든 배열에 있는 값들의 배열을 돌려준다. 집합론에서의 교집합같은 것이다. 위에서 나왔던 예제를 확장해서 이게 어떻게 돌아가는지 보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tens = _.range(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>), eights = _.range(<span class="number">0</span>, <span class="number">100</span>, <span class="number">8</span>), fives = _.range(<span class="number">0</span>, <span class="number">100</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> common = _.intersection(tens, eights, fives );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(common);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [0, 40, 80]</span></span><br></pre></td></tr></table></figure>
<p>쉽지 않나? 비교할 배열들만 써놓으면 underscroe가 나머지는 해준다.</p>
<h2>Objects</h2>
<p><em>is</em> 메소드들은 뭔가를 확인하는데 쓰일꺼라 예상할 수 있고(예를 들어 isEmpty, isEqual 등), underscore는 객체를 복사하거나 확장하거나 기타 등등을 다루는 여러 method들을 제공한다.</p>
<h3>Keys and Values</h3>
<p>커다락 객체에서 key들만 필요하거나 value들만 필요하면? 쉽게 가져올 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Tuts = &#123; NetTuts : <span class="string">'Web Development'</span>,  WPTuts : <span class="string">'WordPress'</span>,  PSDTuts : <span class="string">'PhotoShop'</span>, AeTuts : <span class="string">'After Effects'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> keys = _.keys(Tuts), values = _.values(Tuts);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(keys + values);</span><br><span class="line"><span class="comment">// NetTuts,WPTuts,PSDTuts,AeTutsWeb Development,WordPress,PhotoShop,After Effects</span></span><br></pre></td></tr></table></figure>
<h3>Defaults</h3>
<p>기본으로 사용해야하는 값들과 함께 객체를 만드는데 꽤 유용하다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tuts = &#123; NetTuts : <span class="string">'Web Development'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> defaults = &#123; NetTuts : <span class="string">'Web Development'</span>, niche: <span class="string">'Education'</span>&#125;;</span><br><span class="line">_.defaults(tuts, defaults);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tuts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object &#123; NetTuts="Web Development", niche="Education"&#125;</span></span><br></pre></td></tr></table></figure>
<h2>Functions</h2>
<p>좀 이상하게 들리지만, underscore는 함수에서 돌아가는 함수들을 갖고 있다. 함수들의 대부분은 설명하기 복잡한 것들이어서 제일 간단한 것을 가져왔다.</p>
<h3>Bind</h3>
<p><code>this</code>는 JavaScript에서 설명하기 힘든 부분이고 많은 개발자들을 멘붕하게 만든다. 이 method는 그나마 건들기 쉽게 해준다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; greeting: <span class="string">"Howdy"</span> &#125;,</span><br><span class="line">    f = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.greeting +<span class="string">" "</span>+ name; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> greet = _.bind(f, o);</span><br><span class="line"></span><br><span class="line">greet(<span class="string">"Jess"</span>)</span><br></pre></td></tr></table></figure>
<p>헷갈려서 계속 쳐다보게 만든다. bind 함수는 기본적으로 함수가 어디에서 언제 호출이되건 <code>this</code>값을 유지하게 해준다. <code>this</code>를 가져다가 event를 다룰 때 특별히 유용하다.</p>
<h2>Utilities</h2>
<p>그리고 쓰기에 더 괜찮은게, underscore는 utility 함수들을 대량으로 지원한다. 시간이 없으니 크고 아름다운 것 하나만 보자.</p>
<h3>Templating</h3>
<p>이미 template을 만드는 많은 solution들이 있지만 underscore는 강력하면서 구현이 적다는데 장점이 있다. 대충 예제를 하나 만들어보면</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data =   &#123;site: <span class="string">'NetTuts'</span>&#125;, template =   <span class="string">'Welcome! You are at &lt;%= site %&gt;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parsedTemplate = _.template(template,  data );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(parsedTemplate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Welcome! You are at NetTuts</span></span><br></pre></td></tr></table></figure>
<p>우선, template를 통해 template으로 옮겨서 데이터를 만들 수 있다. 기본적으로, underscore는 모두 custom할 수 있는 ERB(embeded Ruby) 스타일 문자를 사용한다. 그 자리에, template과 data를 가지고 <code>template</code>을 간단하게 호출하면 된다. 필요하면 나중에 업데이트하기 위해 분리된 문자열에 결과를 저장한다.</p>
<p>이건 underscore의 template 중에서 극단적으로 간단한 예제라는걸 명심해라. <code>&lt;% %&gt;</code> 문자를 이용한 template 안쪽에서 어떤 JavaScript 코드를 사용할 수 있다. JSON같은 복잡한 객체를 훑을 필요가 있을 때에는 underscore의 우수한 collection 함수들과 함께 template을 빠르게 만들 수도 있다.</p>
<h2>여전히 왜 써야하는지 모르겠다면</h2>
<blockquote>
<p>jQuery와 underscore를 함께</p>
</blockquote>
<p>jQuery와 underscore는 상호보완적인 것이라 함께 쓰면 더 좋다. 자, jQuery는 아주 괜찮은 케이스들도 있다. DOM을 다룬다거나 애니메이션같은 것들이 말이다. 하지만 더 고수준이나 저수준을 다루지는 않는다. 고수준 이슈를 다루는 Backbone이나 Knockout같은 프레임웍이라면 필요한 부분에 전부 끼워넣을 수 있다.</p>
<p>좀 더 넓게 보자면, jQuery는 DOM을 다루는 기능 때문에 브라우저 밖에서는 거의 쓸 일이 없다. 다른 면으로 underscore는 브라우져에서도 사용할 수 있고 server단에서도 별 이슈없이 사용할 수 있다. 사실, underscore는 node module들이 제일 많이 의존하고 있다. 지금 말한건 그렇다. underscore의 활용에 대해서는 겉만 살짝 긁은 정도다.</p>
]]></content:encoded>
      <comments>http://seoh.github.io/blog/2012/10/09/getting-cozy-with-underscore-js/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[typescript syntax summary]]></title>
      <link>http://seoh.github.io/blog/2012/10/08/typescript-syntax-summary/</link>
      <guid>http://seoh.github.io/blog/2012/10/08/typescript-syntax-summary/</guid>
      <pubDate>Sun, 07 Oct 2012 18:55:00 GMT</pubDate>
      <description>
      <![CDATA[Microsoft가 며칠전 typescript를 발표했다. 아마 CoffeeScript처럼 ECMA Script 표준에 본격적으로 뛰어들기 위한 포석이 아닐까 싶은데, 어찌되었건 현재로는 무려 major IDE(라고는 하지만 Visual studio)에서도 강력하게 지원하고, 사람들이 많이 쓰는 Sublime Text2, Emacs, Vim에서도 플러그인으]]>
      </description>
      <content:encoded><![CDATA[<p>Microsoft가 며칠전 typescript를 발표했다. 아마 CoffeeScript처럼 ECMA Script 표준에 본격적으로 뛰어들기 위한 포석이 아닐까 싶은데, 어찌되었건 현재로는 무려 major IDE(라고는 하지만 Visual studio)에서도 강력하게 지원하고, 사람들이 많이 쓰는 <a href="http://blogs.msdn.com/b/interoperability/archive/2012/10/01/sublime-text-vi-emacs-typescript-enabled.aspx" target="_blank" rel="external">Sublime Text2, Emacs, Vim에서도 플러그인으로 지원</a>된다. 심지어 며칠전에 추가했던 SyntaxHighlighter의 <a href="http://ianobermiller.com/blog/2012/10/03/typescript-syntax-highlighting-for-wordpress/" target="_blank" rel="external">typescript 버전</a>도 벌써 올라왔다. 여하튼 좋은지 아닌지는 일단 적당히 써본 다음에 판단할 수 있으니 발이라도 살짝 담궈보기 위해서 Language Specification 문서를 받아봤으나 읽기엔 너무 길어서 dictation 연습이나 할까 하고 <a href="http://channel9.msdn.com/posts/Anders-Hejlsberg-Introducing-TypeScript" target="_blank" rel="external">소개 동영상</a>을 보려고 시도했다...고 하지만 1분만에 포기하고 그냥 언급된 소스만 보면서 메모해놓은 것들을 정리해봤다.</p>
<h3>typescript syntax summary</h3>
<p>variable type (declared like scala)
// number, string, bool</p>
<p>var name:type;
array expression.
x: string[]</p>
<p>: lambda expression.
() =&gt; retVal</p>
<p>: arg =&gt; retVal
(a: number, b: string) =&gt; a + b</p>
<p>interface declaration and usage</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="interface"><span class="keyword">interface</span> Thing </span>&#123;</span><br><span class="line">    a: <span class="built_in">number</span>;</span><br><span class="line">    b: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">x: Thing</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>object argument is expressed …</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span><span class="params">(x: &#123;a: number, b: string&#125;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>and also expressed</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function process(x: <span class="keyword">Thing</span>) &#123;</span><br><span class="line">    return x.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>optional property</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="keyword">Thing</span> &#123;</span><br><span class="line">    a: number;</span><br><span class="line">    b?: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>method; function property</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="keyword">Thing</span> &#123;</span><br><span class="line">    a: number;</span><br><span class="line">    foo(s: string, n?: number): string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>method overload ...</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="keyword">Thing</span> &#123;</span><br><span class="line">    a: number;</span><br><span class="line">    foo(s: string, n?: number): string;</span><br><span class="line">    foo(n: number): number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var process = function(x: <span class="keyword">Thing</span>) &#123;</span><br><span class="line">    x.foo(<span class="string">"abc"</span>,1)</span><br><span class="line">    x.foo(<span class="string">"abc"</span>)</span><br><span class="line">    x.foo(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>and also expressed</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="keyword">Thing</span> &#123;</span><br><span class="line">    a: number;</span><br><span class="line">    foo: &#123;</span><br><span class="line">        (s: string, n?: number): string;</span><br><span class="line">        (n: number): number;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>you cannot use that way</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="keyword">Thing</span> &#123;</span><br><span class="line">    a: number;</span><br><span class="line">    foo: &#123;</span><br><span class="line">        (n?: number, s: string): string;</span><br><span class="line">        (n: number): number;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>you may wanna use that, then compiler tells you
Optional parameters may only be followed by other optional parameters</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; (n?: <span class="type">number</span>,s: <span class="type">string</span>): <span class="type">string</span>; (n: <span class="type">number</span>): <span class="type">number</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>method overload groupping</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="keyword">Thing</span> &#123;</span><br><span class="line">    a: number;</span><br><span class="line">    foo: &#123;</span><br><span class="line">        (s: string): string;</span><br><span class="line">        (n: number): number;</span><br><span class="line">        data: any;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var process = function(x: <span class="keyword">Thing</span>) &#123;</span><br><span class="line">    x.foo(1)</span><br><span class="line">    x.foo(<span class="string">"abc"</span>)</span><br><span class="line">    x.foo.data = 1</span><br><span class="line">    x.foo.data = <span class="string">"abc"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pre-declared method overload: index method like array, constructor method</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="interface"><span class="keyword">interface</span> Thing </span>&#123;</span><br><span class="line">    a: <span class="built_in">number</span>;</span><br><span class="line">    b: <span class="built_in">string</span>;</span><br><span class="line">    foo: &#123;</span><br><span class="line">        (s: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">        (n: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">        data: <span class="built_in">any</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> (s: <span class="built_in">string</span>): Element;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class definition</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">    <span class="comment">// property</span></span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(x: <span class="built_in">number</span>, y: <span class="built_in">number</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    dist() &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="keyword">this</span>.x*<span class="keyword">this</span>.x + <span class="keyword">this</span>.y*<span class="keyword">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">    static origin = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">p.x = <span class="number">10</span>;</span><br><span class="line">Point.origin.x;</span><br></pre></td></tr></table></figure>
<p>private member: but not in real, just compiler tells &quot;it can`t&quot;</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> color: <span class="keyword">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-&gt;</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Point = (<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Point</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = <span class="string">'red'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>constructor with declaration</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constructor</span><span class="params">( <span class="keyword">public</span> x: number, <span class="keyword">public</span> y: number)</span></span></span><br></pre></td></tr></table></figure>
<p>constructor with default value</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constructor</span><span class="params">( <span class="keyword">public</span> x: number = 0, <span class="keyword">public</span> y: number = 0)</span></span></span><br></pre></td></tr></table></figure>
<p>inheritance // can be use an acceessor (can be duplicated declaration in scope)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(<span class="keyword">public</span> x: <span class="built_in">number</span>, <span class="keyword">public</span> y: <span class="built_in">number</span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Point3D extends Point &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(x: <span class="built_in">number</span>, y: <span class="built_in">number</span>, <span class="keyword">public</span> z: <span class="built_in">number</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>auto-generated closure // compare next sources</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tracker</span> </span>&#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    start() &#123;</span><br><span class="line">        <span class="comment">// legacy expression</span></span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span></span><br><span class="line">        <span class="built_in">window</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            that.count++;</span><br><span class="line">            <span class="built_in">console</span>.log(that.count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">new</span> Tracker()).start();</span><br></pre></td></tr></table></figure>
<p>and</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">    start() &#123;</span><br><span class="line">        <span class="comment">// lambda expression</span></span><br><span class="line">        window.onmousemove = e =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">count</span>++;</span><br><span class="line">            console.log(<span class="keyword">this</span>.<span class="keyword">count</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> Tracker()).start();</span><br></pre></td></tr></table></figure>
<p>module declaration</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span> Hierarchical.Module.Name.Is.Available &#123;</span><br><span class="line">    <span class="reserved">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;&#125;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PrivateClass</span> &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span> Hierarchical.Module.Name.Is.Available &#123;</span><br><span class="line">    <span class="reserved">export</span> <span class="reserved">var</span> partialDeclare</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="reserved">var</span> shortedPath = Hierarchical.Module.Name.Is.Available</span><br><span class="line"><span class="reserved">var</span> p = <span class="keyword">new</span> shortedPath.Point</span><br></pre></td></tr></table></figure>
<p>external module and function</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// target.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="built_in">module</span> target &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">        bark = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"bow wow"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">version</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"v0.0.1"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line">import t = <span class="function"><span class="title">module</span><span class="params">(<span class="string">"target"</span>)</span></span></span><br><span class="line">console.<span class="function"><span class="title">log</span><span class="params">( (new t.target.Dog)</span></span>.<span class="function"><span class="title">bark</span><span class="params">()</span></span> )</span><br><span class="line">console.<span class="function"><span class="title">log</span><span class="params">( t.version()</span></span> )</span><br></pre></td></tr></table></figure>
<p>=&gt;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">03</span>:<span class="number">13</span>:<span class="number">55</span>) <span class="built_in">test</span> seoh$ tsc main.ts <span class="operator">-e</span></span><br><span class="line">bow wow</span><br><span class="line">v0.<span class="number">0.1</span></span><br></pre></td></tr></table></figure>
<p>다른 소스를 보다보면 node.d.ts, jquery.d.ts같은 파일들이 있는데, declarations 옵션으로 컴파일을 하면 c/c++의 header와 같은 개념으로 decoration typescript(d.ts) 파일이 생성된다. 예를들어 위에 있는 target.ts를 컴파일하면</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">03</span>:<span class="number">50</span>:<span class="number">16</span>) test seoh$ tsc --declarations target.ts</span><br><span class="line">(<span class="number">03</span>:<span class="number">50</span>:<span class="number">23</span>) test seoh$ cat target.d.ts </span><br><span class="line">export module target &#123;</span><br><span class="line">    export <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> bark: () =&gt; string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export <span class="function"><span class="keyword">function</span> <span class="title">version</span><span class="params">()</span><span class="type">: string</span></span>;</span><br></pre></td></tr></table></figure>
<p>처럼 선언만 남게 된다.</p>
<p>요즘 만지작거리고 있는 스칼라와 문법이 흡사해서 재미있기도 하고, module, class 개념으로 큰 프로젝트에서 분업할 때 편하긴 할 것 같은데... 아직 어디에 써야할지는 감이 안온다. 다른거 만지다보면 누군가 이런저런 토픽을 던저줄테니 일단 받아먹을 준비 중.</p>
<p>* 위에서 언급된 소스들은 module 부분을 제외하고 Microsoft의 동영상 소개에서 가져온 내용이니 해당 소스들에 대한 권리는 MS에게 있습니다.</p>
]]></content:encoded>
      <comments>http://seoh.github.io/blog/2012/10/08/typescript-syntax-summary/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[DRM-free eBook 출판사 비교]]></title>
      <link>http://seoh.github.io/blog/2012/09/26/comparison-with-drm-free-ebook-publishers/</link>
      <guid>http://seoh.github.io/blog/2012/09/26/comparison-with-drm-free-ebook-publishers/</guid>
      <pubDate>Tue, 25 Sep 2012 15:28:00 GMT</pubDate>
      <description>
      <![CDATA[&quot;인사이트가 PDF 서비스를 시작합니다.&quot; 한국에서 최초로 DRM-free의 eBook을 출간한 회사가 '인사이트'가 아닐까.  4월 18일 저 글이 올라온 이후로 현재까지 인사이트에서는 인사이트 eBook에서 11권의 책을 9800원(뽀모도로 테크닉)~27000원(파이썬 완벽 가이트)를 PDF로 판매하고 있다. 어디 한 플랫폼에 종속되는]]>
      </description>
      <content:encoded><![CDATA[<p>&quot;<a href="http://www.insightbook.co.kr/post/2361" target="_blank" rel="external">인사이트가 PDF 서비스를 시작합니다.</a>&quot; 한국에서 최초로 DRM-free의 eBook을 출간한 회사가 '인사이트'가 아닐까.  4월 18일 저 글이 올라온 이후로 현재까지 인사이트에서는 <a href="http://ebook.insightbook.co.kr/" target="_blank" rel="external">인사이트 eBook</a>에서 11권의 책을 9800원(뽀모도로 테크닉)~27000원(파이썬 완벽 가이트)를 PDF로 판매하고 있다. 어디 한 플랫폼에 종속되는 것을 싫어해서 그때까지 eBook을 구매한 적이 없었는데 인사이트의 이 판매를 보고 반가워서 응원도 할 겸 이벤트(종이책을 구매하는 사람에게 일정기간동안 파이썬 완벽가이드를 27000-&gt;14000으로 할인)도 하는 겸 구매했던 것과 리팩터링 워크북을 포함해 2권을 구매했고 Closure나 Ruby 책도 고민 중에 있다. 그러던 차에 오늘 검색 중 반가운 소식을 들었다. IT서적 전문의 다른 출판사인 한빛미디어에서도 DRM-free eBook을 판매하기 시작했다는 <a href="http://www.hanb.co.kr/ebook/about_ebook.html" target="_blank" rel="external">소개페이지</a>를 발견했다.</p>
<p>IT말고 다른 분야에서도 DRM-free가 나왔으면 좋겠다는 생각도 들었지만 어쨌거나 보는 책의 반 이상, 아니 대다수가 IT관련 책이니 나에게는 좋은 일. &quot;유지보수하기 어렵게 코딩하는 방법: 평생 개발자로 먹고 살 수 있다&quot;라는 무료책을 비롯하여 현재 5권을 판매중이며 가격은 9900원(무료와 자바...를 제외한 나머지 세 책들)~11000원(자바 개발자를 위한 함수형 프로그래밍)로 인사이트에 비해 비교적 저렴한 편이나 대체로 얇은 책들 위주. 여하튼 굉장히 주관적이고 비논리적인 시각으로 특징을 비교해보자면</p>
<p><img src="/blog/images/comparison-with-drm-free-ebook-publishers/1.png" alt="" title="파이썬 완벽 가이드(인사이트) vs 함수형 프로그래밍(한빛미디어)">
<img src="/blog/images/comparison-with-drm-free-ebook-publishers/2.png" alt="" title="파이썬 완벽 가이드(인사이트) vs 함수형 프로그래밍(한빛미디어)"></p>
<ul>
<li>
<p>인사이트</p>
<ul>
<li>주로 기초 서적</li>
<li>(페이지 대비) 저렴한 가격
<ul>
<li>레퍼런스 북 위주라 두꺼운 책들</li>
</ul>
</li>
<li>출간본 그대로의 모습
<ul>
<li>작은 폰트</li>
<li>좌/우 페이지의 좌/우 여백이 다름</li>
</ul>
</li>
<li>구매시 불편함
<ul>
<li>하루 2번 배송</li>
<li>only 무통장입금</li>
</ul>
</li>
</ul>
</li>
<li>
<p>한빛미디어</p>
<ul>
<li>time to market 같은 책들
<ul>
<li>&quot;핵심적인 내용을 빠르게 전달하기 위해 조금 거칠지만 100page 내외의 전자책 전용&quot; - 소개 페이지 中</li>
</ul>
</li>
<li>eBook에 맞춘 편집
<ul>
<li>큰 폰트</li>
<li>(비교적) 적은 여백, 넓은 행간</li>
</ul>
</li>
<li>책보다는 포스팅이나 매거진 느낌
<ul>
<li>&quot;보완되고 발전된 노하우가 정리되면 구매하신 분께 무료로 업데이트&quot; - 소개 페이지 中</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>써놓고 나니 책 가격을 페이지에 비례해서 책정한다는건 무척 어리석은 일이지만 모든 책을 읽어볼 수 없으니 그냥 공개된 정보만 훑어보다가 들었던 생각이다. 어느 쪽이 더 좋은가? 어디가 더 많이 팔릴까? 라고 잠깐 생각을 해봤는데 둘 다 썩 좋은 질문은 아닌거 같다. 단순히 '편집'만 가지고 이야기를 하자면, 여백이나 행간은 한빛쪽이 확실히 읽기 좋고 폰트 자체는 인사이트쪽이 읽기 좋고, 작은 폰트는 아이패드류나 데스크탑에서 읽기 편하고 큰 폰트는 5&quot;~7&quot; 정도에서 읽기 편하다. (그 이하의 화면 크기는 PDF 자체가 읽기 불편하다.) 책 종류 자체도 인사이트는 기본서(혹은 레퍼런스)같은 느낌이고 한빛은  실용서(혹은 노하우)같은 느낌이다. 둘 다 필요한 종류의 책들.</p>
<p>비교 이외의 한가지 토픽을 더 던지자면, DRM-free에 대한 정보가 더 없나 검색하다가 &quot;<a href="http://www.hanb.co.kr/network/view.html?bi_id=1821" target="_blank" rel="external">DRM으로부터의 해방, 영원히</a>&quot;라는 글을 읽었다. 사실 eBook이 유행하기 전에도 어둠의 경로로는 만화/소설/잡지 등의 스캔이 떠돌고 있었고 여전히 그렇다. 이런 상황에서 DRM이 없어지면 '무단 복제'가 더 빈번해질까? 판매량이 더 감소할까? 저 링크 속의 글에 있는 &quot;이해할 수 없는 것은, 책 판매량은 줄지 않았다는 것이다. 사실, 판매량은 그 해에 살짝 올라갔다.&quot;라는 말이 한국의 실정에도 적용될 수는 없더라도 그 의미를 같이 하지 않을까. 그렇기에 인사이트나 한빛미디어에서도 이런 도전을 하고 있는 것이겠고, 그것을 응원한다 :)</p>
]]></content:encoded>
      <comments>http://seoh.github.io/blog/2012/09/26/comparison-with-drm-free-ebook-publishers/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[커피스크립트를 쓰면 좋은 10가지 이유]]></title>
      <link>http://seoh.github.io/blog/2012/09/19/10-good-reasons-use-coffeescript/</link>
      <guid>http://seoh.github.io/blog/2012/09/19/10-good-reasons-use-coffeescript/</guid>
      <pubDate>Wed, 19 Sep 2012 09:32:00 GMT</pubDate>
      <description>
      <![CDATA[
Translation of &quot;10 good reasons to use CoffeeScript&quot; into Korean, under the same license as the original.

Caike souza는 CoffeeScript의 어떤 점들이 좋은지, 왜 이게 프로젝트에서 쓰일만한지에 대해 보여줄 것이다.
커피스크립트는 최근에 ]]>
      </description>
      <content:encoded><![CDATA[<blockquote>
<h3>Translation of &quot;<a href="http://www.netmagazine.com/features/10-good-reasons-use-coffeescript" target="_blank" rel="external">10 good reasons to use CoffeeScript</a>&quot; into Korean, under the same license as the original.</h3>
</blockquote>
<p>Caike souza는 CoffeeScript의 어떤 점들이 좋은지, 왜 이게 프로젝트에서 쓰일만한지에 대해 보여줄 것이다.</p>
<p>커피스크립트는 최근에 만들어진 인기있는 언어다. 커피스크립트는 자바스크립트의 강력한 객체 모델을 훨씬 간단한 문법으로 사용할 수 있을 뿐만 아니라 이미 존재하는 특징들 또한 쓸 수 있다. 여전히 커피스크립트가 배울만하다고 생각한다면, 내 대부분의 프로젝트에서 왜 쓰고 있는 10가지 이유들을 보자.</p>
<h1>1. 깔끔한 문법</h1>
<p>C언어의 문법에서 강하게 영향을 받은 자바스크립트처럼이 아니라 커피스크립트의 문법은 루비와 파이썬에서 영향을 받았다. 파이썬과 루비 코드를 본 적이 있으면 커피스크립트의 문법 몇개가 친숙할 것이다. 세미콜론으로 문장을 구분하지 않고 줄 단위로, 메소드의 호출이나 조건을 쓰는데 괄호는 옵션, 공백에 민감하고, 이 모든건 훨씬 쉽게 읽기 위한 문법이다.</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">'Hello World'</span></span><br><span class="line">sayHello message</span><br></pre></td></tr></table></figure>
<h1>2. 자바스크립트의 좋은 부분만 생성</h1>
<p>자바스크립트에는 알려진 단점들이 있다. 커피스크립트는 항상 자바스크립트의 장점만을 생성하도록 최선을 다할 것이다. 한가지 예로 커피스크립트로 생성되는 모든 자바스크립트 파일은 자신의 영역(scope)를 가진다. 익명 함수로 코드를 감싸면 개발자가 이름이 충돌(naming collision)하지 않게 방지하고 전역 네임스페이스를 섞이지 않도록 해준다. 간단한 HelloWorld를 자바스크립트로 생성시킨건 다음과 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sayHello;  </span><br><span class="line">  sayHello = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(message);</span><br><span class="line">  &#125;;  </span><br><span class="line">  sayHello(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;).call(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>위의 예시에서 <code>sayHello</code> 함수는 익명 함수 내에서만 가능하고 전역 네임스페이스에는 추가되지 않는다.</p>
<h1>3. Fat Arrow</h1>
<p>자바스크립트는 진짜 강력하고 유연한 언어다. 그러나 때론 이 특징들이 개발자가 이때문에 추가적인 코드를 쓰도록 요구한다. 커피스크립트에서는 언어 내부에서 이런걸 해결한다.</p>
<p>다음 예제에서 우리는 callback 함수의 내부에서부터 커피 객체의 context로 접근한 필요가 있다. 자바스크립트 개발자들 사이에서 널리 사용되는 규칙으로, callback 함수 외부에서 객체의 context 내부 변수로 값을 전달한다, 그래서 callback 함수로부터 참조가 되고 있어야한다, 다음 예시처럼</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coffee = &#123;</span><br><span class="line">  isFull: <span class="literal">true</span>,</span><br><span class="line">  watchDrink: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    $(<span class="string">'.drink a'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      that.isFull = <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>이런 방법을 커피스크립트로 변환한다면 여전히 가능하다.</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">coffee =</span><br><span class="line">  <span class="attribute">isFull</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attribute">watchDrink</span>: <span class="function">-&gt;</span></span><br><span class="line">    that = <span class="keyword">this</span></span><br><span class="line">    $(<span class="string">'.drink a'</span>).<span class="literal">on</span> <span class="string">'click'</span>, <span class="function">-&gt;</span></span><br><span class="line">      that.isFull = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>그러나 커피스크립트는 뚱뚱한 화살표 연산자(Fat Arrow Operation, 그냥 Fat Arrow는 원어로 표기해야겠다)로 똑같은걸 더 효과적으로 보여주는 방법이 있다. 이전의 커피스크립트 코드에서 이제 Fat Arrow를 쓰면 다음과 같다.</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">coffee =</span><br><span class="line">  <span class="attribute">isFull</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attribute">watchDrink</span>: <span class="function">-&gt;</span></span><br><span class="line">    $(<span class="string">'.drink a'</span>).<span class="literal">on</span> <span class="string">'click'</span>, <span class="function">=&gt;</span></span><br><span class="line">      <span class="property">@isFull</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>fat arrow를 사용하면, 커피의 context 안쪽으로 @ 연산자를 거쳐 callback 함수의 안쪽으로 참조할 수 있다. 커피스크립트에서 @는 <code>this</code> 키워드 대신이지만 =&gt; 안쪽에서만 사용가능하고, context 바깥의 this를 참조한다.</p>
<h1>4. String interpolation</h1>
<p>커피스크립트의 String interpolation은 루비처럼 작동한다. 자바스크립트에서처럼 +로 합치는 것 대신에 다음과 같이 겹따옴표 내부에서 #{} 안에 표현하면 된다.</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'John Doe'</span></span><br><span class="line"><span class="built_in">console</span>.log <span class="string">"Hi, my name is <span class="subst">#&#123;name&#125;</span>"</span></span><br></pre></td></tr></table></figure>
<h1>5. List comprehensions</h1>
<p>자바스크립트에서 엘리먼트 집합들을 하나씩 훑는 방법 중 가장 흔항 방법은 for 반복이다. 자바스크립트로 짠 for 반복의 간단한 예시다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'Foo'</span>, <span class="string">'Bar'</span>, <span class="string">'Baz'</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; names.length; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(names[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>파이썬 세계에서 잘 알려진 list comprehension을 사용해 배열을 순회할 수 있게 해준다.</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Foo'</span>, <span class="string">'Bar'</span>, <span class="string">'Baz'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="keyword">for</span> name <span class="keyword">in</span> names</span><br></pre></td></tr></table></figure>
<p>자바스크립트의 for문과는 다르게, list comprehensions는 표현식이므로 반환해서 할당할 수도 있다.</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Foo'</span>, <span class="string">'Bar'</span>, <span class="string">'Baz'</span>]</span><br><span class="line">friends = (name <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">when</span> name != <span class="string">'Bar'</span>)</span><br></pre></td></tr></table></figure>
<h1>6. Conditional modifier</h1>
<p>기본적으로 if와 unless같은 조건식을 postfix 형태로 쓸 수 있다. 아래 코드를 읽어보면 그냥 영어 문장을 읽는 것같이 들릴 것이다.</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allowEntrance() <span class="keyword">unless</span> age &lt; <span class="number">21</span></span><br><span class="line">allowEntrance() <span class="keyword">if</span> age &gt;= <span class="number">21</span></span><br></pre></td></tr></table></figure>
<h1>7. the class keyword</h1>
<p>자바스크립트는 prototype의 객체지향언어라서 클래스 선언에 대한 내부적인 지원은 없다. 그러나 커피스크립트는 지원한다. 컴파일러가 자바스크립트 코드로 적당히 표현되게 필요한 해석들을 잘 해준다. 커피스크립트에서의 클래스는 아래처럼 쓸 수 있다.</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span>  </span></span><br><span class="line">  <span class="attribute">constructor</span>: <span class="function"><span class="params">(<span class="property">@name</span>)</span> -&gt;</span>  </span><br><span class="line"> </span><br><span class="line">  <span class="attribute">brew</span>: <span class="function">-&gt;</span></span><br><span class="line">    <span class="built_in">console</span>.log <span class="string">'Brewing'</span></span><br><span class="line"> </span><br><span class="line">  <span class="attribute">description</span>: <span class="function">-&gt;</span></span><br><span class="line">    <span class="built_in">console</span>.log <span class="string">"Coffee is <span class="subst">#&#123;<span class="property">@name</span>&#125;</span>"</span></span><br></pre></td></tr></table></figure>
<p>커피스크립트 클래스에서 객체를 만드는 방법은 자바스크립트에서 new 연산자를 통해 생성자 함수를 호출해서 만드는 방법과 완전히 똑같다.</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frenchCoffee = <span class="keyword">new</span> Coffee(<span class="string">'French'</span>)</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>전망</li>
</ol>
<p>자바스크립트의 창시자인 Brendan Eich처럼 자바스크립트 커뮤니티의 주요한 사람들이 커피스크립트 문법 표준화를 하고 있다. class 키워드를 통한 prototype 상속 같은 것들, @ 연산자나 =&gt;같은 것들은 실제로 몇년 안에 자바스크립트에 들어갈 것이다.</p>
<blockquote>
<p>&quot;커피스크립트의 class, super, @같은 문법적인 좋은 것들로 prototype의 상속을 표준화시키려고 열심히 만들고 있다&quot;</p>
</blockquote>
<p class="right">- 자바스크립트의 창시자, Brendan Eich</p>
<h1>9. 커뮤니티 전파</h1>
<p>RoR 3.1 버전부터 커피스크립트를 out-of-the-box(바로 쓸 수 있게끔) 지원하기 시작했다. 파이썬이나 PHP같은 다른 언어의 Web Framework들은 컴파일 단계를 지원하는 서드파티 라이브러리들을 갖고 있다. 또 많은 유닛 테스트 프레임워크들이 커피스크립트를 지원하기에 커뮤니티들이 활발히 포용하고 있다.</p>
<h1>10. 배우기 좋은 자원들</h1>
<p>커피스크립트 공식 웹사이트는 훌륭한 문서와 바로 돌려볼 수 있는 예제들을 제공한다. 언어가 어떻게 만들어졌는지 자세하게 파볼 사람들을 위해 소스코드 또한 웹사이트에 잘 문서화되어있고 읽을 수 있다. 더 배울 수 있도록 많은 온라인 강좌, 책, 전자책, 블로그 포스팅들이 있다. CodeSchool.com은 입문할 수 있는 무료 커피스크립트 강좌가 있는 곳이다.</p>
<hr>
<p>이것들 덕분에 커피스크립트에 더 관심을 갖게 되었다. 이 글이 커피스크립트가 배울 가치가 있는 언어인지에 대한 토론하는데 도움이 되길 바란다.</p>
<style type="text/css">
.right {text-align: right;}
</style>]]></content:encoded>
      <comments>http://seoh.github.io/blog/2012/09/19/10-good-reasons-use-coffeescript/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[코딩 인터뷰 완전 분석 215쪽 문제 18.10 풀이]]></title>
      <link>http://seoh.github.io/blog/2012/09/12/coding-interview-p215-18-10/</link>
      <guid>http://seoh.github.io/blog/2012/09/12/coding-interview-p215-18-10/</guid>
      <pubDate>Wed, 12 Sep 2012 12:52:00 GMT</pubDate>
      <description>
      <![CDATA[
사전에 등장하고 길이가 같은 두 단어가 주어졌을 때, 한 번에 글자 하나만 바꾸어 한 단어를 다른 단어로 변환하는 프로그램을 작성하라. 변환 과정에서 만들어지는 각 단어도 사전에 있는 단어여야 한다.
[실행 예]
input : DAMP, LIKE
output: DAMP -&gt; LAMP -&gt; LIMP -&gt; LIME -&gt; LIKE
[사전 ]]>
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>사전에 등장하고 길이가 같은 두 단어가 주어졌을 때, 한 번에 글자 하나만 바꾸어 한 단어를 다른 단어로 변환하는 프로그램을 작성하라. 변환 과정에서 만들어지는 각 단어도 사전에 있는 단어여야 한다.
[실행 예]
input : DAMP, LIKE
output: DAMP -&gt; LAMP -&gt; LIMP -&gt; LIME -&gt; LIKE
[사전 데이터]
네 글자 단어 - <a href="http://www.insightbook.co.kr/wp-content/uploads/2012/09/word4.txt" target="_blank" rel="external">word4</a>
다섯 글자 단어 - <a href="http://www.insightbook.co.kr/wp-content/uploads/2012/09/word5.txt" target="_blank" rel="external">word5</a></p>
</blockquote>
<blockquote>
<p>[심화 문제 - 풀지 않아도 됩니다]
심화문제 1: 가장 적은 수의 단어를 써서 변환하도록 프로그램을 작성해봅시다.
심화문제 2: 가장 많은 수의 단어를 써서 변환하도록 프로그램을 작성해봅시다. 단, 변환 과정에서 같은 단어가 두 번 나오면 안됩니다.</p>
</blockquote>
<p>가장 단순한 접근.
모든 데이터를 메모리에 올려놓고, 앞에서부터 한글자씩 대입해서 사전에서 검색해보고 있으면 치환. 목적지에 도착할 때까지 반복. 혹시 한바퀴(문자열 길이)를 돌 때까지 치환할 단어가 없으면 찾을 수 없다고 판단. 일종의 Greedy로 답을 찾을 수는 있지만 가장 빠른 답인지 보장하지는 못한다.</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># synonym.coffee</span></span><br><span class="line">v = process.argv</span><br><span class="line"><span class="keyword">if</span> v.length &lt; <span class="number">5</span></span><br><span class="line">    process.exit -<span class="number">1</span></span><br><span class="line">n = parseInt v[<span class="number">3</span>]</span><br><span class="line">src = v[<span class="number">4</span>].toLowerCase()</span><br><span class="line">dst = v[<span class="number">5</span>].toLowerCase()</span><br><span class="line"></span><br><span class="line">data = <span class="built_in">require</span>(<span class="string">'fs'</span>).readFileSync <span class="string">'./word'</span> + n + <span class="string">'.txt'</span></span><br><span class="line">data = data.toString().split <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> data.indexOf(dst) <span class="keyword">is</span> -<span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log <span class="string">'dst does not exist in data text'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log src</span><br><span class="line"><span class="keyword">while</span> src <span class="keyword">isnt</span> dst</span><br><span class="line">    __ = src</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0.</span>..n]</span><br><span class="line">        temp = src.substring(<span class="number">0</span>, i) + dst.charAt(i) + src.substring(i+<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">if</span> __ <span class="keyword">isnt</span> temp <span class="keyword">and</span> data.indexOf(temp) <span class="keyword">isnt</span> -<span class="number">1</span></span><br><span class="line">            src = temp</span><br><span class="line">            <span class="built_in">console</span>.log <span class="string">"-&gt; <span class="subst">#&#123;src&#125;</span>"</span></span><br><span class="line">            <span class="keyword">if</span> src <span class="keyword">is</span> dst <span class="keyword">then</span> <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> __ <span class="keyword">is</span> src</span><br><span class="line">        <span class="built_in">console</span>.log <span class="string">"IMPOSSIBLE"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>그리고 출력값</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ coffee synonym.coffee 4 damp like</span><br><span class="line">damp</span><br><span class="line">-<span class="ruby">&gt; lamp</span><br><span class="line"></span>-<span class="ruby">&gt; limp</span><br><span class="line"></span>-<span class="ruby">&gt; lime</span><br><span class="line"></span>-<span class="ruby">&gt; like</span></span><br></pre></td></tr></table></figure>
<p>소스에서는 생략했지만, 6회(두번째 루프) 만에 찾았다.</p>
<p>Shorted Path나 Longest Path를 찾기 위해서는 edge에 index 정보를 기록하는 graph를 만들어야할꺼 같은데, 그러려면 모델링하는데만 O(n^2)만큼의 시간이 걸린다.</p>
<p>좀 더 좋은 방법을 찾아보자.</p>
]]></content:encoded>
      <comments>http://seoh.github.io/blog/2012/09/12/coding-interview-p215-18-10/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[코딩 인터뷰 완전 분석 210쪽 17.3 변형 문제 풀이]]></title>
      <link>http://seoh.github.io/blog/2012/09/05/coding-interview-p210-17.3-modified/</link>
      <guid>http://seoh.github.io/blog/2012/09/05/coding-interview-p210-17.3-modified/</guid>
      <pubDate>Wed, 05 Sep 2012 12:51:00 GMT</pubDate>
      <description>
      <![CDATA[
자연수 n을 입력받고, n!의 계산 결과 중 마지막에 붙은 연속된 0의 개수와 연속된 0 바로 앞에 나오는 숫자를 구하라.


[실행 예]
input n: 15
output: 3 8


[설명]
15!은 1307674368000이므로, 마지막에 연속된 0은 3개이고, 바로 앞의 숫자는 8이다.



조건 *



n의 범위는 1 이상, 10000 이하입니]]>
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>자연수 n을 입력받고, n!의 계산 결과 중 마지막에 붙은 연속된 0의 개수와 연속된 0 바로 앞에 나오는 숫자를 구하라.</p>
</blockquote>
<blockquote>
<p>[실행 예]
input n: 15
output: 3 8</p>
</blockquote>
<blockquote>
<p>[설명]
15!은 1307674368000이므로, 마지막에 연속된 0은 3개이고, 바로 앞의 숫자는 8이다.</p>
</blockquote>
<blockquote>
<ul>
<li>조건 *</li>
</ul>
</blockquote>
<blockquote>
<p>n의 범위는 1 이상, 10000 이하입니다.
테스트 입력은 다음과 같습니다.
20! = 2432902008176640000
30! = 265252859812191058636308480000000
40! = 815915283247897734345611269596115894272000000000
50! = 30414093201713378043612608166064768844377641568960512000000000000
100! = 93326215443944152681699238856266700490715968264381621468592963
8952175999932299156089414639761565182862536979208272237582511852
10916864000000000000000000000000
프로그래밍 언어에서 제공하는 자릿수 제한 없는 곱셈을 이용하거나, 이런 형태의 곱셈 함수를 직접 구현해도 답을 얻을 수 있지만, 문제의 의도와는 다릅니다.
정답 검토의 편의를 위해 블로그 포스팅에 2012!와 10000!의 결과를 남겨주세요.
(심화 문제) 연속된 0 앞에 나오는 여러 숫자를 구하는 것도 가능하니, 심심하신 분은 도전해보세요. ^^</p>
</blockquote>
<h3>1. Simple Approach</h3>
<p>아주 간단하게 생각해서 굳이 다 계산할 필요없이 마지막 원하는 자릿수만 남겨보자.</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># simple.factorial.coffee</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">N = <span class="number">2012</span></span><br><span class="line">digit = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">digit = digit * <span class="number">10</span> <span class="keyword">while</span> k-- <span class="keyword">isnt</span> <span class="number">0</span></span><br><span class="line">zero = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1.</span>.N]</span><br><span class="line">    n = n*i</span><br><span class="line">    <span class="keyword">while</span> n % <span class="number">10</span> <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">        n = n/<span class="number">10</span></span><br><span class="line">        zero++</span><br><span class="line"></span><br><span class="line">    n = n%digit</span><br><span class="line">    <span class="built_in">console</span>.log <span class="string">"<span class="subst">#&#123;i&#125;</span>! = ...<span class="subst">#&#123;n&#125;</span>*10^<span class="subst">#&#123;zero&#125;</span>"</span></span><br></pre></td></tr></table></figure>
<p>k는 원하는 자리 수. 3자리만 끊어서 보도록 했다. 결과는</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2012</span><span class="subst">!</span> <span class="subst">=</span> <span class="attribute">...</span><span class="number">928</span><span class="subst">*</span><span class="number">10</span>^<span class="number">501</span></span><br><span class="line"><span class="preprocessor">[</span>Finished <span class="keyword">in</span> <span class="number">0.7</span>s<span class="preprocessor">]</span><span class="markup"></span></span><br></pre></td></tr></table></figure>
<h3>2. without 2, 5</h3>
<p>0의 개수를 결정하는 2와 5는 따로 처리한다. N까지 숫자를 모두 곱해서 소인수분해를 하면 2가 5보다 항상 클까? non-zero digit of factorial로 검색하니 바로 맨 위에 이 <a href="http://comeoncodeon.wordpress.com/2009/06/20/lastnon-zero-digit-of-factorial/" target="_blank" rel="external">포스팅</a>이 나왔다. Approach1은 누구나 생각할 수 있고 2에 대한 수학적인 증명이 있어야할텐데 그건 차차 생각해보도록 하고 일단 구현해보도록 했다.</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#reduce2and5.factorial.coffee</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">N = <span class="number">2012</span></span><br><span class="line"></span><br><span class="line">digit = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> k-- <span class="keyword">isnt</span> <span class="number">0</span></span><br><span class="line">    digit = digit * <span class="number">10</span></span><br><span class="line"></span><br><span class="line">zero = <span class="number">0</span></span><br><span class="line">n2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1.</span>.N]</span><br><span class="line">    j = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> j % <span class="number">10</span> <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">        j /= <span class="number">10</span></span><br><span class="line">        zero++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> j % <span class="number">2</span> <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">        j /= <span class="number">2</span></span><br><span class="line">        n2++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> j % <span class="number">5</span> <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">        j /= <span class="number">5</span></span><br><span class="line">        n2--</span><br><span class="line">        <span class="built_in">console</span>.error i <span class="keyword">if</span> n2 <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">        zero++</span><br><span class="line"></span><br><span class="line">    n = n*j % digit</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> n2-- <span class="keyword">isnt</span> <span class="number">0</span></span><br><span class="line">    n = n*<span class="number">2</span> % digit</span><br><span class="line"><span class="built_in">console</span>.log <span class="string">"<span class="subst">#&#123;N&#125;</span>! = ...<span class="subst">#&#123;n&#125;</span>*10^<span class="subst">#&#123;zero&#125;</span>"</span></span><br></pre></td></tr></table></figure>
<p>결과는</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2012</span><span class="subst">!</span> <span class="subst">=</span> <span class="attribute">...</span><span class="number">928</span><span class="subst">*</span><span class="number">10</span>^<span class="number">501</span></span><br><span class="line"><span class="preprocessor">[</span>Finished <span class="keyword">in</span> <span class="number">0.2</span>s<span class="preprocessor">]</span><span class="markup"></span></span><br></pre></td></tr></table></figure>
<p>확실하게 줄었다. Approach3과 4에 대해서는 더 생각해봐야겠는데 일단 카페 마감 시간이라 나가도록 하겠다.</p>
]]></content:encoded>
      <comments>http://seoh.github.io/blog/2012/09/05/coding-interview-p210-17.3-modified/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[문제로 풀어보는 알고리즘 149쪽 문제 3.c 풀이]]></title>
      <link>http://seoh.github.io/blog/2012/09/01/coding-interview-p149-3-c/</link>
      <guid>http://seoh.github.io/blog/2012/09/01/coding-interview-p149-3-c/</guid>
      <pubDate>Sat, 01 Sep 2012 12:50:00 GMT</pubDate>
      <description>
      <![CDATA[
자연수 n을 입력받아 집합 {0, 1, 2, …, n-1}을 하나 이상의 집합으로 나누는 방법을 모두 출력하는 프로그램을 작성하세요.
[실행 예]
input n: 3
{0, 1, 2}
{0} {1, 2}
{1} {0, 2}
{2} {0, 1}
{0} {1} {2}



참고 *


n의 범위는 크게 상관이 없지만, 대략 16 이하라고 가정하시면 되겠습니다]]>
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>자연수 n을 입력받아 집합 {0, 1, 2, …, n-1}을 하나 이상의 집합으로 나누는 방법을 모두 출력하는 프로그램을 작성하세요.
[실행 예]
input n: 3
{0, 1, 2}
{0} {1, 2}
{1} {0, 2}
{2} {0, 1}
{0} {1} {2}</p>
</blockquote>
<blockquote>
<ul>
<li>참고 *</li>
</ul>
<ol>
<li>n의 범위는 크게 상관이 없지만, 대략 16 이하라고 가정하시면 되겠습니다. ^^</li>
</ol>
</blockquote>
<ol start="2">
<li>집합으로 나눈 경우를 출력하는 방법은 상관없습니다.</li>
</ol>
<ul>
<li>{1} {0, 2}를 {0, 2} {1}로 표현해도 되고, 1, 0 2로 표현해도 됩니다. (다른 형식도)</li>
<li>또, {0} {1, 2}가 먼저 출력되든, {0} {1} {2}가 먼저 출력되든 상관 없습니다. 빠짐없이 출력하기만 하면 됩니다.</li>
</ul>
<p>곰곰히 생각해서 나름대로 잘 풀었다고 생각했는데 다른 사람들의 풀이를 보니 다 똑같아서 알고리즘의 설명은 생략하겠다. 그 대신에 잠깐 생각해본게 과연 이렇게 하나씩 추가하는 알고리즘에서 중복(순서가 바뀐 같은 집합)이 존재하지 않을까? 하는 의문이다. { ArrayN, ArrayM, ... } 이렇게 부분집합 n, m 이 있을 때 { ArrayM, ArrayN, ... } 라고 순서가 바뀐 다른 부분집합이 있을까? 답은 없다. n에서 제일 작은 n[0]과 m에서 제일 작은 m[0]가 있을 때 n[0] &lt; m[0]라면 항상 n[0]가 앞에 있는 집합에 속해있다. 크기 순서대로 입력이 된다고 가정했을 때 m[0]가 n[0]보다 앞에 있으려면 n[0]보다 작은 숫자가 먼저 입력되어있는 부분 집합에 m[0]가 속해야하는데 그럼 그 집합에서 가장 작은 숫자가 m[0]가 아니기 때문에 모순되므로 m[0]가 n[0]보다 앞에 올 수 없어서 중복된 집합은 존재하지 않는다.</p>
<p>그리고 coffeescript를 실행할 때 compile하고 다시 node로 실행시키는 일을 두번 하기 싫은데 coffee에서 직접 파일을 입력받아 실행시키는 옵션은 없고 stdio로 script text를 받아서 실행시키는 옵션은 있어서 출력한 뒤 파이프로 넘기게 계속 명령어를 입력했는데 (cat test.coffee | coffee -s) argument를 입력받게 되니 coffee파일까지 커서를 옮겼다가 다시 argument로 커서를 옮겼다가 하기 귀찮아서 bash script 문서를 구글링해서 하나 만들었다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> <span class="operator">-lt</span> <span class="number">1</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"you must give me coffee"</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">cat <span class="variable">$1</span> | coffee <span class="operator">-s</span> <span class="variable">$&#123;@:2&#125;</span></span><br></pre></td></tr></table></figure>
<p>중요한건 이게 아니고 다시 문제로 돌아가서 소스를 보자면</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># subset.coffee</span></span><br><span class="line">n = parseInt process.argv[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">Array.prototype.clone = <span class="function"><span class="params">()</span> -&gt;</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> <span class="keyword">this</span></span><br><span class="line">        item = item.clone() <span class="keyword">if</span> item.constructor <span class="keyword">is</span> Array</span><br><span class="line">        ret.push item</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">data = [ [[<span class="number">0</span>]] ]</span><br><span class="line"><span class="function"></span><br><span class="line"><span class="title">add</span> = <span class="params">(arr, n)</span> -&gt;</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> arr</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0.</span>..row.length]</span><br><span class="line">            (c = row.clone())[i].push n</span><br><span class="line">            ret.push c</span><br><span class="line">        row.push [n]</span><br><span class="line">        ret.push row</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1.</span>..n]</span><br><span class="line">    data = add data, i</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log data</span><br></pre></td></tr></table></figure>
<p>그리고 실행</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(21:58:11) coffee seoh$ ./c.sh subset.coffee 4</span><br><span class="line"><span class="comment">[ <span class="comment">[ <span class="comment">[ 0, 1, 2, 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 1, 2 ]</span>, <span class="comment">[ 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 1, 3 ]</span>, <span class="comment">[ 2 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 1 ]</span>, <span class="comment">[ 2, 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 1 ]</span>, <span class="comment">[ 2 ]</span>, <span class="comment">[ 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 2, 3 ]</span>, <span class="comment">[ 1 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 2 ]</span>, <span class="comment">[ 1, 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 2 ]</span>, <span class="comment">[ 1 ]</span>, <span class="comment">[ 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 3 ]</span>, <span class="comment">[ 1, 2 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0 ]</span>, <span class="comment">[ 1, 2, 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0 ]</span>, <span class="comment">[ 1, 2 ]</span>, <span class="comment">[ 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 3 ]</span>, <span class="comment">[ 1 ]</span>, <span class="comment">[ 2 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0 ]</span>, <span class="comment">[ 1, 3 ]</span>, <span class="comment">[ 2 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0 ]</span>, <span class="comment">[ 1 ]</span>, <span class="comment">[ 2, 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0 ]</span>, <span class="comment">[ 1 ]</span>, <span class="comment">[ 2 ]</span>, <span class="comment">[ 3 ]</span> ]</span> ]</span></span><br></pre></td></tr></table></figure>
<p>cat test.coffee | coffee -s로 실행을 하면 내부적으로 어떤 구조로 node를 실행시키는지 모르겠지만 [ 'node', '.', '-s' ] 라는 세 argument가 기본적으로 붙는다. 그런데 -s는 help에도 안나오고 직접 node -s로 하면 unrecognized flag라고 나오고. 뭔지 모르겠지만 귀찮아서 패스.</p>
<p>사실 처음에는 다른 방법으로 접근했다가 포기했다. 어차피 모든 부분집합의 원소의 합은 n으로 일정하니 일단 그 크기를 나누는 것을 n=4일 때를 예로 들어,</p>
<p>4
3 + 1
2 + 2
2 + 1 + 1
1 + 1 + 1 + 1</p>
<p>로 나타낼 수 있다. 각 행마다 하나씩 예로 들자면</p>
<p>{ 0, 1, 2, 3 }
{ 0, 1, 2 }, { 3 }
{ 0, 1 }, { 2, 3 }
{ 0, 1 }, { 2 } , { 3 }
{ 0 }, { 1 }, { 2 }, { 3 }</p>
<p>로 나타낼 수 있다. 그래서</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># split.coffee</span></span><br><span class="line">n = parseInt process.argv[<span class="number">3</span>]</span><br><span class="line"><span class="function"></span><br><span class="line"><span class="title">split</span> = <span class="params">(n)</span> -&gt;</span></span><br><span class="line">    split.ret.clear</span><br><span class="line">    split.arr.clear</span><br><span class="line"></span><br><span class="line">    __split(n, <span class="number">0</span>, n)</span><br><span class="line">    split.ret</span><br><span class="line"></span><br><span class="line">split.arr = []</span><br><span class="line">split.ret = []</span><br><span class="line"><span class="function"></span><br><span class="line"><span class="title">__split</span> = <span class="params">(n, i, m)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">        split.ret.push split.arr.slice(<span class="number">0</span>, i)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> m &gt; n</span><br><span class="line">        m = n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">1</span> .. m]</span><br><span class="line">        split.arr[i] = j</span><br><span class="line">        __split n-j, i+<span class="number">1</span>, j</span><br><span class="line"></span><br><span class="line">n &amp;&amp; <span class="built_in">console</span>.log split n</span><br><span class="line">exports &amp;&amp; exports.split = split</span><br></pre></td></tr></table></figure>
<p>라고 [1.6 수분할] 챕터를 참고해서 만들었다. 그런데 이걸 깔끔하게 정리해서 개수를 맞춰서 경우의 수를 만들 수 있는 방법을 못찾아서 다른 방법을 강구하게 되었다. 단순히 생각했을 때, memoization처럼 <code>memo['2.1.1']['2'].indexOf('1.2')</code>라는 식으로 2+1+1을 '2.1.1'로 {1, 2}는 '1.2'처럼 문자열로 만들어서 HashMap을 하나 만들면 구현은 편한데 어차피 모든 경우의 수를 만들고 거기에서 필터링하는거나 마찬가지라 (정확히 말하면 '가지치기'의 방법이 떠오르지 않아서) 비효율적이라 포기했다. 나중에 시간나면 지금처럼 bottom-up같은 방법이 아니라 top-down으로 할 수 있는 방법이 없나 찾아봐야겠다.</p>
]]></content:encoded>
      <comments>http://seoh.github.io/blog/2012/09/01/coding-interview-p149-3-c/#disqus_comments</comments>
    </item>
    
  </channel>
</rss>